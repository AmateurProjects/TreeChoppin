<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport"
        content="width=device-width,
                initial-scale=1,
                minimum-scale=1,
                maximum-scale=1,
                user-scalable=no,
                viewport-fit=cover" />
  <title>Tree Chopping Prototype</title>
  <style>
    html, body { margin:0; padding:0; overflow:hidden; background:#0b0f12; }
    canvas { display:block; }

    /* Prevent selection/highlight/callout on mobile */
    /* Hard-disable touch zoom / highlight */
    html, body {
      touch-action: none;
      -webkit-touch-callout: none;
      -webkit-user-select: none;
      user-select: none;
      -webkit-tap-highlight-color: transparent;
    }

    /* Still allow selecting text inside the HUD if you ever want to copy; optional */
    
    /* #hud { -webkit-user-select: none; user-select: none; } */

    /* Minimal HUD */
    #hud {
      position: fixed;
      left: 12px; top: 12px;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      color: #e8f0f7;
      user-select: none;
      background: rgba(0,0,0,0.35);
      padding: 10px 12px;
      border-radius: 12px;
      backdrop-filter: blur(6px);
      max-width: 340px;
    }
    #hint { font-size: 12px; opacity: 0.9; margin-top: 6px; line-height: 1.3; }
    .statline { margin-top: 6px; font-size: 13px; }
    #score, #wood { font-weight: 800; }

    #chopWrap { margin-top: 10px; }
    #barOuter {
      width: 260px; height: 10px;
      border-radius: 999px;
      background: rgba(255,255,255,0.12);
      overflow: hidden;
    }
    #barInner {
      width: 0%;
      height: 100%;
      background: rgba(120, 220, 120, 0.95);
    }
    #targetLine { font-size: 12px; margin-top: 6px; opacity: 0.9; }
    #centerDot {
      position: fixed; left: 50%; top: 50%;
      width: 6px; height: 6px;
      transform: translate(-50%, -50%);
      border-radius: 50%;
      background: rgba(255,255,255,0.7);
      box-shadow: 0 0 0 3px rgba(0,0,0,0.25);
      pointer-events: none;
      transition: background 0.15s, box-shadow 0.15s, width 0.15s, height 0.15s;
    }
    #centerDot.targeting {
      width: 10px; height: 10px;
      background: rgba(120, 220, 120, 0.95);
      box-shadow: 0 0 0 3px rgba(0,0,0,0.25), 0 0 8px rgba(120,220,120,0.5);
    }
    .floatText {
      position: fixed;
      pointer-events: none;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      font-weight: 900;
      font-size: 18px;
      color: #ffe066;
      text-shadow: 0 2px 6px rgba(0,0,0,0.5);
      z-index: 50;
    }
    /* ---------- Touch controls (mobile) ---------- */
    .touch-ui {
      position: fixed;
      inset: 0;
      pointer-events: none;
      z-index: 10;
    }
    .touch-ui.show { display: block; }
    .touch-ui { display: none; }

    .touch-joystick {
      position: fixed;
      left: 18px;
      bottom: 18px;
      width: 140px;
      height: 140px;
      border-radius: 999px;
      background: rgba(0,0,0,0.25);
      border: 1px solid rgba(255,255,255,0.18);
      backdrop-filter: blur(6px);
      pointer-events: auto;
      touch-action: none;
    }
    .touch-joystick .stick {
      position: absolute;
      left: 50%;
      top: 50%;
      width: 64px;
      height: 64px;
      border-radius: 999px;
      transform: translate(-50%, -50%);
      background: rgba(255,255,255,0.18);
      border: 1px solid rgba(255,255,255,0.22);
      box-shadow: 0 10px 24px rgba(0,0,0,0.25);
    }

    .touch-chop {
      position: fixed;
      right: 18px;
      bottom: 18px;
      width: 108px;
      height: 108px;
      border-radius: 999px;
      background: rgba(255,255,255,0.12);
      border: 1px solid rgba(255,255,255,0.22);
      color: #e8f0f7;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      font-weight: 800;
      letter-spacing: 0.2px;
      pointer-events: auto;
      touch-action: none;
      user-select: none;
      -webkit-user-select: none;
      display: grid;
      place-items: center;
      backdrop-filter: blur(6px);
    }

    .touch-tip {
      position: fixed;
      left: 12px;
      right: 12px;
      bottom: 170px;
      text-align: center;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      color: rgba(232,240,247,0.85);
      font-size: 12px;
      pointer-events: none;
      text-shadow: 0 2px 10px rgba(0,0,0,0.45);
    }

    /* ---------- Modal overlay ---------- */
    .modalOverlay{
      position: fixed;
      inset: 0;
      display: grid;
      place-items: center;
      background: rgba(0,0,0,0.55);
      backdrop-filter: blur(8px);
      z-index: 999;          /* above HUD + touch UI */
      pointer-events: auto;
      touch-action: none;    /* prevent scroll/zoom while modal open */
    }

    .modalCard{
      width: min(520px, calc(100vw - 32px));
      background: rgba(16, 22, 28, 0.92);
      border: 1px solid rgba(255,255,255,0.14);
      border-radius: 18px;
      box-shadow: 0 18px 70px rgba(0,0,0,0.45);
      padding: 18px 18px 14px;
      color: #e8f0f7;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
    }

    .modalTitle{
      font-weight: 900;
      font-size: 18px;
      line-height: 1.25;
      margin-bottom: 14px;
    }

    .modalRow{
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .modalBtn{
      border: 1px solid rgba(255,255,255,0.16);
      background: rgba(255,255,255,0.10);
      color: #e8f0f7;
      border-radius: 14px;
      padding: 12px 16px;
      font-weight: 900;
      cursor: pointer;
      user-select: none;
      -webkit-user-select: none;
      touch-action: none;
    }
    .modalBtn:active{
      transform: translateY(1px);
    }

    .modalBtnPlus{
      width: 56px;
      height: 56px;
      font-size: 26px;
      display: grid;
      place-items: center;
    }

    .modalValue{
      min-width: 92px;
      font-size: 20px;
      font-weight: 900;
      padding: 10px 12px;
      border-radius: 14px;
      background: rgba(0,0,0,0.22);
      border: 1px solid rgba(255,255,255,0.10);
      text-align: center;
    }

    .modalSpacer{
      flex: 1;
    }

    .modalBtnPlay{
      min-width: 110px;
      height: 56px;
      font-size: 16px;
    }

    .modalBtn:disabled{
      opacity: 0.45;
      cursor: not-allowed;
      transform: none;
    }

    .modalSubtext{
      margin-top: 10px;
      font-size: 12px;
      opacity: 0.85;
    }

    .modalHidden{
      display: none !important;
    }

    /* ---------- Vendor greeting toast ---------- */
    #vendorGreeting {
      position: fixed;
      bottom: 180px;
      left: 50%;
      transform: translateX(-50%);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      font-weight: 800;
      font-size: 15px;
      color: #ffe066;
      background: rgba(0,0,0,0.55);
      padding: 10px 20px;
      border-radius: 14px;
      backdrop-filter: blur(6px);
      text-align: center;
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.35s;
      z-index: 60;
      white-space: nowrap;
    }
    #vendorGreeting.show { opacity: 1; }

    /* ---------- Vendor shop modal ---------- */
    .shopCard {
      width: min(560px, calc(100vw - 32px));
      max-height: calc(100vh - 64px);
      overflow-y: auto;
      background: rgba(14, 20, 28, 0.95);
      border: 1px solid rgba(255,215,0,0.25);
      border-radius: 18px;
      box-shadow: 0 18px 70px rgba(0,0,0,0.55), 0 0 30px rgba(255,215,0,0.08);
      padding: 20px 20px 16px;
      color: #e8f0f7;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
    }
    .shopTitle {
      font-weight: 900;
      font-size: 20px;
      color: #ffe066;
      margin-bottom: 4px;
    }
    .shopSubtitle {
      font-size: 12px;
      opacity: 0.75;
      margin-bottom: 14px;
    }
    .shopSection {
      font-weight: 800;
      font-size: 13px;
      color: #ffe066;
      margin: 14px 0 8px;
      text-transform: uppercase;
      letter-spacing: 0.6px;
    }
    .shopItem {
      display: flex;
      align-items: center;
      gap: 12px;
      padding: 10px 12px;
      border-radius: 12px;
      background: rgba(255,255,255,0.04);
      border: 1px solid rgba(255,255,255,0.08);
      margin-bottom: 8px;
      transition: background 0.15s;
    }
    .shopItem:hover { background: rgba(255,255,255,0.08); }
    .shopIcon {
      width: 38px; height: 38px;
      border-radius: 10px;
      background: rgba(255,215,0,0.12);
      display: grid;
      place-items: center;
      font-size: 20px;
      flex-shrink: 0;
    }
    .shopInfo { flex: 1; }
    .shopItemName { font-weight: 800; font-size: 14px; }
    .shopItemDesc { font-size: 11px; opacity: 0.7; margin-top: 2px; }
    .shopBuyBtn {
      border: 1px solid rgba(255,215,0,0.3);
      background: rgba(255,215,0,0.12);
      color: #ffe066;
      border-radius: 10px;
      padding: 8px 14px;
      font-weight: 900;
      font-size: 13px;
      cursor: pointer;
      white-space: nowrap;
      flex-shrink: 0;
    }
    .shopBuyBtn:active { transform: translateY(1px); }
    .shopBuyBtn:disabled {
      opacity: 0.35;
      cursor: not-allowed;
      transform: none;
    }
    .shopBuyBtn.owned {
      border-color: rgba(120,220,120,0.3);
      background: rgba(120,220,120,0.12);
      color: #78dc78;
    }
    .shopCloseBtn {
      border: 1px solid rgba(255,255,255,0.16);
      background: rgba(255,255,255,0.08);
      color: #e8f0f7;
      border-radius: 12px;
      padding: 10px 24px;
      font-weight: 900;
      font-size: 14px;
      cursor: pointer;
      margin-top: 14px;
    }
    .shopCloseBtn:active { transform: translateY(1px); }
    .shopWood {
      font-size: 13px;
      opacity: 0.85;
      margin-bottom: 10px;
    }
    .shopWood span { font-weight: 900; color: #ffe066; }

    #donationModal, .touch-ui, .touch-joystick, .touch-chop, .modalBtn, .modalCard {
      -webkit-user-select: none;
      user-select: none;
      -webkit-touch-callout: none;
      -webkit-tap-highlight-color: transparent;
    }
    button, .modalBtn, .touch-chop, .touch-joystick {
      touch-action: none;
      -webkit-user-select: none;
      user-select: none;
    }




  </style>
</head>
<body>
  <div id="hud">
    <div class="statline">Score: <span id="score">0</span> &nbsp;‚Ä¢&nbsp; Wood: <span id="wood">0</span></div>
    <div id="hint">
      Move: <b>WASD</b> ‚Ä¢ Sprint: <b>Shift</b> ‚Ä¢ Chop: <b>Hold Left Click</b> ‚Ä¢ Shop: <b>E</b><br/>
      Aim at a tree, get close, and chop. Find the hidden vendor!
    </div>
    <div id="chopWrap">
      <div id="barOuter"><div id="barInner"></div></div>
      <div id="targetLine">Target: <span id="targetName">None</span></div>
    </div>
  </div>
  <div id="centerDot"></div>

  <!-- Touch UI (shown automatically on mobile / touch devices) -->
  <div id="touchUI" class="touch-ui">
    <div id="joyBase" class="touch-joystick" aria-label="Move joystick">
      <div id="joyStick" class="stick"></div>
    </div>
    <div id="chopBtn" class="touch-chop" aria-label="Chop button">CHOP</div>
    <div id="vendorTouchBtn" class="touch-chop" aria-label="Interact" style="display:none; right:18px; bottom:140px; width:80px; height:80px; font-size:12px; background:rgba(255,215,0,0.15); border-color:rgba(255,215,0,0.3);">SHOP</div>
  </div>

  <!-- Vendor greeting toast -->
  <div id="vendorGreeting"></div>

  <!-- Vendor Shop modal -->
  <div id="vendorShopModal" class="modalOverlay modalHidden" role="dialog" aria-modal="true">
    <div class="shopCard">
      <div class="shopTitle">Battle Pass Shop</div>
      <div class="shopSubtitle">The wandering vendor has rare goods&hellip;</div>
      <div class="shopWood">Your Wood: <span id="shopWoodCount">0</span></div>

      <div class="shopSection">Wood Bundles</div>
      <div id="shopWoodItems"></div>

      <div class="shopSection">Powerups</div>
      <div id="shopPowerItems"></div>

      <button id="shopCloseBtn" class="shopCloseBtn">Leave Shop</button>
    </div>
  </div>

  <!-- Donation Modal (blocks input; game continues rendering behind) -->
  <div id="donationModal" class="modalOverlay" role="dialog" aria-modal="true" aria-labelledby="modalTitle">
    <div class="modalCard">
      <div class="modalTitle" id="modalTitle">Welcome to Tree Chop! How much do you donate?</div>

      <div class="modalRow">
        <button id="donatePlusBtn" class="modalBtn modalBtnPlus" aria-label="Increase donation">+</button>
        <div id="donateValue" class="modalValue">$0</div>

        <div class="modalSpacer"></div>

        <button id="playBtn" class="modalBtn modalBtnPlay" disabled>Play</button>
      </div>

    </div>
  </div>


  <script type="module">
    import * as THREE from "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js";

    // ---------- Basic setup ----------
    const scene = new THREE.Scene();

    // Blue sky background
    scene.background = new THREE.Color(0x78b7ff);

    // Softer fog (optional, keep it light so it doesn‚Äôt darken the scene)
    scene.fog = new THREE.Fog(0x78b7ff, 140, 520);

    const camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 500);
    camera.position.set(0, 6, 10);

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
    document.body.appendChild(renderer.domElement);
    renderer.domElement.tabIndex = 0;           // make canvas focusable
    renderer.domElement.style.outline = "none"; // no focus ring
    renderer.domElement.focus();
    // Prevent browser touch gestures from interfering with gameplay
    renderer.domElement.style.touchAction = "none";

    // Extra iOS Safari guards: prevent pinch/double-tap zoom
    document.addEventListener("gesturestart", (e) => e.preventDefault(), { passive:false });
    document.addEventListener("gesturechange", (e) => e.preventDefault(), { passive:false });
    document.addEventListener("gestureend", (e) => e.preventDefault(), { passive:false });

    // Block double-tap zoom
    let lastTouchEnd = 0;
    document.addEventListener("touchend", (e) => {
      const now = Date.now();
      if (now - lastTouchEnd < 300) {
        e.preventDefault();
      }
      lastTouchEnd = now;
    }, { passive:false });

    // ---------- Lights ----------
    // Sky + ground bounce lighting (very outdoor-looking)
    const hemi = new THREE.HemisphereLight(0xbfdcff, 0x2a4a2a, 0.95);
    scene.add(hemi);

    // Sun light
    const sun = new THREE.DirectionalLight(0xffffff, 1.25);
    sun.position.set(80, 140, 60);
    sun.castShadow = false; // keep simple for now
    scene.add(sun);

    // Visible sun disc in the sky (simple)
    const sunDisc = new THREE.Mesh(
      new THREE.SphereGeometry(6, 24, 16),
      new THREE.MeshBasicMaterial({ color: 0xfff2b0 })
    );
    sunDisc.position.copy(sun.position);
    scene.add(sunDisc);


    // ---------- Ground (rolling hills) ----------
    const groundSize = 520;
    const groundSegs = 220;

    // More segments = smoother hills
    const groundGeo = new THREE.PlaneGeometry(groundSize, groundSize, groundSegs, groundSegs);
    groundGeo.rotateX(-Math.PI / 2);

    // Lightweight 2D value-noise (no external libs)
    function hash2(x, z) {
      // deterministic pseudo-random 0..1
      const s = Math.sin(x * 127.1 + z * 311.7) * 43758.5453123;
      return s - Math.floor(s);
    }
    function smoothstep(t) { return t * t * (3 - 2 * t); }
    function lerp(a, b, t) { return a + (b - a) * t; }

    function valueNoise2D(x, z) {
      const x0 = Math.floor(x), z0 = Math.floor(z);
      const x1 = x0 + 1,       z1 = z0 + 1;

      const sx = smoothstep(x - x0);
      const sz = smoothstep(z - z0);

      const n00 = hash2(x0, z0);
      const n10 = hash2(x1, z0);
      const n01 = hash2(x0, z1);
      const n11 = hash2(x1, z1);

      const ix0 = lerp(n00, n10, sx);
      const ix1 = lerp(n01, n11, sx);
      return lerp(ix0, ix1, sz);
    }

    // Fractal noise (octaves) for nicer hills
    function fbm(x, z) {
      let amp = 1.0;
      let freq = 0.035;
      let sum = 0.0;
      let norm = 0.0;

      for (let i = 0; i < 5; i++) {
        sum += (valueNoise2D(x * freq, z * freq) * 2 - 1) * amp;
        norm += amp;
        amp *= 0.5;
        freq *= 2.0;
      }
      return sum / norm; // ~ -1..1
    }

    const HILL_HEIGHT = 7.0;

    function getGroundHeight(x, z) {
      return fbm(x, z) * HILL_HEIGHT;
    }

    // Approximate ground normal using finite differences
    function getGroundNormal(x, z) {
      const eps = 0.75;
      const hL = getGroundHeight(x - eps, z);
      const hR = getGroundHeight(x + eps, z);
      const hD = getGroundHeight(x, z - eps);
      const hU = getGroundHeight(x, z + eps);

      const n = new THREE.Vector3(hL - hR, 2 * eps, hD - hU);
      return n.normalize();
    }


    // Displace vertices in Y
    const pos = groundGeo.attributes.position;
    for (let i = 0; i < pos.count; i++) {
      const x = pos.getX(i);
      const z = pos.getZ(i);

      // Rolling hills: broad + gentle
      const h = fbm(x, z);
      const height = h * HILL_HEIGHT;

      pos.setY(i, height);
    }
    pos.needsUpdate = true;
    groundGeo.computeVertexNormals();

    // Grass material
    const groundMat = new THREE.MeshStandardMaterial({
      color: 0x2f8f3f,      // grass green
      roughness: 1.0,
      metalness: 0.0
    });

    const ground = new THREE.Mesh(groundGeo, groundMat);
    ground.position.y = 0;
    scene.add(ground);

    // Rocks (sit on hills + align to slope)
    const rockColliders = []; // { x, z, radius }
    const rockMat = new THREE.MeshStandardMaterial({ color: 0x2b2f33, roughness: 1 });
    for (let i = 0; i < 30; i++) {
      const size = 0.4 + Math.random() * 0.8;
      const g = new THREE.DodecahedronGeometry(size);
      g.computeBoundingSphere();
      const r = g.boundingSphere ? g.boundingSphere.radius : size;

      const m = new THREE.Mesh(g, rockMat);

      const x = (Math.random() - 0.5) * 120;
      const z = (Math.random() - 0.5) * 120;

      const y = getGroundHeight(x, z);
      const n = getGroundNormal(x, z);

      // Place rock so it rests on surface (center lifted by radius)
      m.position.set(x, y + r * 0.9, z);

      // Align "up" to slope normal, then random twist around that normal
      m.quaternion.setFromUnitVectors(new THREE.Vector3(0, 1, 0), n);
      m.quaternion.premultiply(new THREE.Quaternion().setFromAxisAngle(n, Math.random() * Math.PI * 2));

      scene.add(m);
      rockColliders.push({ x, z, radius: r * 0.9 });
    }

    // ---------- Player ----------
    const player = new THREE.Group();
    scene.add(player);

    const bodyGeo = new THREE.CapsuleGeometry(0.45, 0.8, 6, 10);
    const bodyMat = new THREE.MeshStandardMaterial({ color: 0x7aa7ff, roughness: 0.7 });
    const body = new THREE.Mesh(bodyGeo, bodyMat);
    body.position.y = 0.9;
    player.add(body);

    const axeGeo = new THREE.BoxGeometry(0.1, 0.6, 0.1);
    const axeMat = new THREE.MeshStandardMaterial({ color: 0xd9d9d9, roughness: 0.4 });
    const axe = new THREE.Mesh(axeGeo, axeMat);
    axe.position.set(0.55, 1.1, 0.2);
    player.add(axe);

    player.position.set(0, 0, 0);

    // ---------- UI ----------
    const scoreEl = document.getElementById("score");
    const woodEl = document.getElementById("wood");
    const barInner = document.getElementById("barInner");
    const targetNameEl = document.getElementById("targetName");
    const centerDot = document.getElementById("centerDot");
    const hud = document.getElementById("hud");
    // ---------- Donation Modal ----------
    const donationModal = document.getElementById("donationModal");
    const donatePlusBtn = document.getElementById("donatePlusBtn");
    const donateValueEl = document.getElementById("donateValue");
    const playBtn = document.getElementById("playBtn");

    const donationValues = [0, 1, 10, 69];
    let donationIndex = 0;        // starts at $0
    let donateTappedOnce = false; // Play only works after + tapped at least once
    let modalOpen = true;

    function updateDonationUI(){
      donateValueEl.textContent = `$${donationValues[donationIndex]}`;
      playBtn.disabled = !donateTappedOnce;

      // When at max ($69), + becomes inert (still clickable but does nothing)
      if (donationIndex >= donationValues.length - 1) {
        donatePlusBtn.style.opacity = "0.75";
      } else {
        donatePlusBtn.style.opacity = "1";
      }
    }

    function closeDonationModal(){
      modalOpen = false;
      donationModal.classList.add("modalHidden");

      // Return focus to the canvas so keyboard works immediately
      renderer.domElement.focus();
    }

    function openDonationModal(){
    modalOpen = true;

    // Reset donation state
    donationIndex = 0;
    donateTappedOnce = false;
    updateDonationUI();

    donationModal.classList.remove("modalHidden");
    }




    // Keep clicks/touches from "falling through" to the canvas
    donationModal.addEventListener("pointerdown", (e) => {
      e.preventDefault();
      e.stopPropagation();
    }, { passive:false });

    donatePlusBtn.addEventListener("click", (e) => {
      e.preventDefault();
      e.stopPropagation();
      initAudio();

      donateTappedOnce = true;
      if (donationIndex < donationValues.length - 1) {
        donationIndex++;
      }
      updateDonationUI();
    });

    playBtn.addEventListener("click", (e) => {
      e.preventDefault();
      e.stopPropagation();
      initAudio();

      if (!donateTappedOnce) return; // hard guard
      closeDonationModal();

      // Start the random timer AFTER the modal is dismissed
      scheduleNextDonation(clock.elapsedTime);
    });

    updateDonationUI();




    let score = 0;
    let wood = 0;

    // ---------- Powerup state ----------
    let chopMultiplier = 1.0;      // multiplied into chopRate
    let speedMultiplier = 1.0;     // multiplied into move speed
    let pickupRadiusMultiplier = 1.0; // multiplied into wood pickup range
    let doubleDropActive = false;  // 2√ó wood from trees

    // ---------- Vendor system ----------
    const VENDOR_DETECT_RADIUS = 8;   // player sees vendor
    const VENDOR_INTERACT_RADIUS = 4; // close enough to shop
    const VENDOR_GREETINGS = [
      "Psst! Over here, lumberjack!",
      "Hey! Wanna see my wares?",
      "Battle pass, fresh stock!",
      "The finest goods in the forest!",
      "You look like you need an upgrade!",
    ];

    let vendorGroup = null;
    let vendorVisible = false;
    let vendorShopOpen = false;
    let vendorGreeted = false;     // so greeting only shows once per encounter
    let vendorPos = { x: 0, z: 0 };

    const vendorGreetingEl = document.getElementById("vendorGreeting");
    const vendorShopModalEl = document.getElementById("vendorShopModal");
    const shopCloseBtn = document.getElementById("shopCloseBtn");
    const shopWoodCountEl = document.getElementById("shopWoodCount");
    const shopWoodItemsEl = document.getElementById("shopWoodItems");
    const shopPowerItemsEl = document.getElementById("shopPowerItems");

    // Battle pass catalog
    const shopCatalog = {
      woodBundles: [
        { id: "w10",  name: "Small Bundle",   desc: "+10 Wood",    icon: "ü™µ", cost: 0, woodGain: 10 },
        { id: "w25",  name: "Medium Bundle",  desc: "+25 Wood",    icon: "ü™µ", cost: 5, woodGain: 25 },
        { id: "w50",  name: "Large Bundle",   desc: "+50 Wood",    icon: "ü™ì", cost: 15, woodGain: 50 },
        { id: "w100", name: "Mega Bundle",    desc: "+100 Wood",   icon: "üèóÔ∏è", cost: 35, woodGain: 100 },
      ],
      powerups: [
        { id: "pChop",   name: "Sharp Axe",       desc: "2√ó chop speed (permanent)",       icon: "‚ö°", cost: 20,  apply() { chopMultiplier = 2.0; } },
        { id: "pSpeed",  name: "Swift Boots",      desc: "1.5√ó move speed (permanent)",     icon: "üëü", cost: 15,  apply() { speedMultiplier = 1.5; } },
        { id: "pPickup", name: "Magnetic Gloves",  desc: "2√ó pickup radius (permanent)",    icon: "üß≤", cost: 12,  apply() { pickupRadiusMultiplier = 2.0; } },
        { id: "pDouble", name: "Double Drops",     desc: "Trees drop 2√ó wood (permanent)",  icon: "üéÅ", cost: 30,  apply() { doubleDropActive = true; } },
        { id: "pUltra",  name: "Ultra Axe",        desc: "4√ó chop speed (permanent)",       icon: "üî•", cost: 60,  apply() { chopMultiplier = 4.0; } },
      ]
    };
    const ownedPowerups = new Set();

    function createVendor() {
      // Pick a random location far-ish from spawn
      let x, z;
      do {
        x = (Math.random() - 0.5) * 100;
        z = (Math.random() - 0.5) * 100;
      } while (Math.hypot(x, z) < 25); // at least 25 units from origin

      vendorPos.x = x;
      vendorPos.z = z;

      const y = getGroundHeight(x, z);

      vendorGroup = new THREE.Group();
      vendorGroup.position.set(x, y, z);

      // Body (purple robe)
      const robeGeo = new THREE.CapsuleGeometry(0.5, 1.0, 6, 10);
      const robeMat = new THREE.MeshStandardMaterial({ color: 0x8844cc, roughness: 0.7 });
      const robe = new THREE.Mesh(robeGeo, robeMat);
      robe.position.y = 1.0;
      vendorGroup.add(robe);

      // Head
      const headGeo = new THREE.SphereGeometry(0.32, 8, 8);
      const headMat = new THREE.MeshStandardMaterial({ color: 0xf0d0a0, roughness: 0.8 });
      const head = new THREE.Mesh(headGeo, headMat);
      head.position.y = 1.9;
      vendorGroup.add(head);

      // Hat (cone)
      const hatGeo = new THREE.ConeGeometry(0.45, 0.7, 8);
      const hatMat = new THREE.MeshStandardMaterial({ color: 0x5522aa, roughness: 0.6 });
      const hat = new THREE.Mesh(hatGeo, hatMat);
      hat.position.y = 2.4;
      vendorGroup.add(hat);

      // Backpack (box of wares)
      const packGeo = new THREE.BoxGeometry(0.6, 0.6, 0.4);
      const packMat = new THREE.MeshStandardMaterial({ color: 0x8a6a3a, roughness: 0.9 });
      const pack = new THREE.Mesh(packGeo, packMat);
      pack.position.set(0, 1.1, -0.45);
      vendorGroup.add(pack);

      // Floating indicator (gold diamond above head)
      const indGeo = new THREE.OctahedronGeometry(0.18, 0);
      const indMat = new THREE.MeshStandardMaterial({ color: 0xffdd44, emissive: 0xffaa00, emissiveIntensity: 0.4, roughness: 0.3 });
      const indicator = new THREE.Mesh(indGeo, indMat);
      indicator.position.y = 3.0;
      indicator.name = "vendorIndicator";
      vendorGroup.add(indicator);

      vendorGroup.visible = false;
      vendorVisible = false;
      vendorGreeted = false;

      scene.add(vendorGroup);
    }

    function relocateVendor() {
      let x, z;
      do {
        x = (Math.random() - 0.5) * 120;
        z = (Math.random() - 0.5) * 120;
      } while (Math.hypot(x - player.position.x, z - player.position.z) < 30);

      vendorPos.x = x;
      vendorPos.z = z;
      const y = getGroundHeight(x, z);
      vendorGroup.position.set(x, y, z);
      vendorGroup.visible = false;
      vendorVisible = false;
      vendorGreeted = false;
    }

    function playVendorSound() {
      if (!audioCtx) return;
      const t = audioCtx.currentTime;
      // Mystical chime
      [660, 880, 1100].forEach((freq, i) => {
        const osc = audioCtx.createOscillator();
        osc.type = "sine";
        osc.frequency.setValueAtTime(freq, t + i * 0.08);
        const gain = audioCtx.createGain();
        gain.gain.setValueAtTime(0.0001, t + i * 0.08);
        gain.gain.exponentialRampToValueAtTime(0.12, t + i * 0.08 + 0.02);
        gain.gain.exponentialRampToValueAtTime(0.0001, t + i * 0.08 + 0.25);
        osc.connect(gain);
        gain.connect(masterGain);
        osc.start(t + i * 0.08);
        osc.stop(t + i * 0.08 + 0.3);
      });
    }

    function playPurchaseSound() {
      if (!audioCtx) return;
      const t = audioCtx.currentTime;
      const osc = audioCtx.createOscillator();
      osc.type = "sine";
      osc.frequency.setValueAtTime(520, t);
      osc.frequency.exponentialRampToValueAtTime(1040, t + 0.1);
      const gain = audioCtx.createGain();
      gain.gain.setValueAtTime(0.0001, t);
      gain.gain.exponentialRampToValueAtTime(0.15, t + 0.02);
      gain.gain.exponentialRampToValueAtTime(0.0001, t + 0.18);
      osc.connect(gain);
      gain.connect(masterGain);
      osc.start(t);
      osc.stop(t + 0.22);
    }

    function renderShopItems() {
      shopWoodCountEl.textContent = String(wood);

      // Wood bundles
      shopWoodItemsEl.innerHTML = "";
      for (const item of shopCatalog.woodBundles) {
        const row = document.createElement("div");
        row.className = "shopItem";
        const canAfford = wood >= item.cost;
        row.innerHTML = `
          <div class="shopIcon">${item.icon}</div>
          <div class="shopInfo">
            <div class="shopItemName">${item.name}</div>
            <div class="shopItemDesc">${item.desc}</div>
          </div>
          <button class="shopBuyBtn" ${canAfford ? "" : "disabled"}>${item.cost === 0 ? "FREE" : item.cost + " Wood"}</button>
        `;
        row.querySelector(".shopBuyBtn").addEventListener("click", (e) => {
          e.preventDefault(); e.stopPropagation();
          if (wood < item.cost) return;
          wood -= item.cost;
          wood += item.woodGain;
          woodEl.textContent = String(wood);
          spawnFloatText(player.position, `+${item.woodGain} Wood`);
          playPurchaseSound();
          renderShopItems();
        });
        shopWoodItemsEl.appendChild(row);
      }

      // Powerups
      shopPowerItemsEl.innerHTML = "";
      for (const item of shopCatalog.powerups) {
        const row = document.createElement("div");
        row.className = "shopItem";
        const owned = ownedPowerups.has(item.id);
        const canAfford = wood >= item.cost && !owned;
        row.innerHTML = `
          <div class="shopIcon">${item.icon}</div>
          <div class="shopInfo">
            <div class="shopItemName">${item.name}</div>
            <div class="shopItemDesc">${item.desc}</div>
          </div>
          <button class="shopBuyBtn ${owned ? "owned" : ""}" ${canAfford ? "" : "disabled"}>${owned ? "OWNED" : item.cost + " Wood"}</button>
        `;
        if (!owned) {
          row.querySelector(".shopBuyBtn").addEventListener("click", (e) => {
            e.preventDefault(); e.stopPropagation();
            if (wood < item.cost || ownedPowerups.has(item.id)) return;
            wood -= item.cost;
            woodEl.textContent = String(wood);
            ownedPowerups.add(item.id);
            item.apply();
            spawnFloatText(player.position, item.name + " acquired!");
            playPurchaseSound();
            renderShopItems();
          });
        }
        shopPowerItemsEl.appendChild(row);
      }
    }

    function openVendorShop() {
      vendorShopOpen = true;
      modalOpen = true;
      renderShopItems();
      vendorShopModalEl.classList.remove("modalHidden");
      vendorGreetingEl.classList.remove("show");
    }

    function closeVendorShop() {
      vendorShopOpen = false;
      modalOpen = false;
      vendorShopModalEl.classList.add("modalHidden");
      renderer.domElement.focus();
      // After closing shop, vendor relocates to a new spot
      relocateVendor();
    }

    shopCloseBtn.addEventListener("click", (e) => {
      e.preventDefault(); e.stopPropagation();
      closeVendorShop();
    });

    vendorShopModalEl.addEventListener("pointerdown", (e) => {
      e.preventDefault(); e.stopPropagation();
    }, { passive: false });

    // "E" key to interact with vendor
    document.addEventListener("keydown", (e) => {
      if (e.code === "KeyE") {
        if (vendorShopOpen) {
          closeVendorShop();
        } else if (vendorVisible && !modalOpen) {
          // Check proximity
          const dx = player.position.x - vendorPos.x;
          const dz = player.position.z - vendorPos.z;
          if (Math.hypot(dx, dz) <= VENDOR_INTERACT_RADIUS) {
            initAudio();
            openVendorShop();
          }
        }
      }
    });

    function updateVendor(dt) {
      if (!vendorGroup) return;

      const dx = player.position.x - vendorPos.x;
      const dz = player.position.z - vendorPos.z;
      const dist = Math.hypot(dx, dz);

      // Reveal vendor when player gets close
      if (!vendorVisible && dist <= VENDOR_DETECT_RADIUS) {
        vendorGroup.visible = true;
        vendorVisible = true;
        playVendorSound();
      }

      // Greeting
      if (vendorVisible && !vendorGreeted && dist <= VENDOR_DETECT_RADIUS) {
        vendorGreeted = true;
        const greet = VENDOR_GREETINGS[Math.floor(Math.random() * VENDOR_GREETINGS.length)];
        vendorGreetingEl.textContent = greet + " (Press E to shop)";
        vendorGreetingEl.classList.add("show");
      }

      // Hide greeting when too far or shop is open
      if (vendorGreeted && (dist > VENDOR_DETECT_RADIUS || vendorShopOpen)) {
        vendorGreetingEl.classList.remove("show");
      }

      // Re-show greeting prompt when close but not shopping
      if (vendorVisible && vendorGreeted && dist <= VENDOR_INTERACT_RADIUS && !vendorShopOpen) {
        vendorGreetingEl.textContent = "Press E to open shop";
        vendorGreetingEl.classList.add("show");
      }

      // Hide if player walked away
      if (vendorVisible && dist > VENDOR_DETECT_RADIUS * 1.5) {
        vendorGroup.visible = false;
        vendorVisible = false;
        vendorGreeted = false;
        vendorGreetingEl.classList.remove("show");
      }

      // Animate the floating indicator
      const ind = vendorGroup.getObjectByName("vendorIndicator");
      if (ind) {
        ind.position.y = 3.0 + Math.sin(performance.now() * 0.003) * 0.2;
        ind.rotation.y += dt * 2.0;
      }

      // Make vendor face player when visible
      if (vendorVisible) {
        const angle = Math.atan2(dx, dz);
        vendorGroup.rotation.y = angle;
      }

      // Touch: show/hide interact button
      if (isTouchDevice && vendorTouchBtn) {
        vendorTouchBtn.style.display =
          (vendorVisible && dist <= VENDOR_INTERACT_RADIUS && !vendorShopOpen) ? "" : "none";
      }
    }

    createVendor();

    // Touch vendor interact button
    const vendorTouchBtn = document.getElementById("vendorTouchBtn");
    vendorTouchBtn?.addEventListener("pointerdown", (e) => {
      if (!isTouchDevice) return;
      e.preventDefault();
      initAudio();
      if (vendorShopOpen) {
        closeVendorShop();
      } else if (vendorVisible && !modalOpen) {
        const ddx = player.position.x - vendorPos.x;
        const ddz = player.position.z - vendorPos.z;
        if (Math.hypot(ddx, ddz) <= VENDOR_INTERACT_RADIUS) {
          openVendorShop();
        }
      }
    }, { passive: false });

    // ---------- Donation modal random timer ----------
    let nextDonationAt = 0;

    function scheduleNextDonation(nowSeconds){
      // random 10‚Äì15 seconds
      nextDonationAt = nowSeconds + 10 + Math.random() * 5;
    }


    // ---------- Input ----------
    const keys = new Set();

    document.addEventListener("keydown", (e) => {
      // Keep focus / pointer lock stable and stop browser shortcuts
      if (["KeyW","KeyA","KeyS","KeyD","KeyE","ShiftLeft","ShiftRight","Space",
          "ArrowUp","ArrowDown","ArrowLeft","ArrowRight"].includes(e.code)) {
        e.preventDefault();
      }
      keys.add(e.code);
    }, { passive: false });

    document.addEventListener("keyup", (e) => {
      keys.delete(e.code);
    });

    // Avoid "stuck keys" if the tab loses focus
    window.addEventListener("blur", () => keys.clear());

    let isChopping = false;
    window.addEventListener("mousedown", (e) => { if (e.button === 0) isChopping = true; });
    window.addEventListener("mouseup", (e) => { if (e.button === 0) isChopping = false; });

    // ---------- Touch controls ----------
    const touchUI = document.getElementById("touchUI");
    const joyBase = document.getElementById("joyBase");
    const joyStick = document.getElementById("joyStick");
    const chopBtn = document.getElementById("chopBtn");
    const touchTip = document.getElementById("touchTip");

    const isTouchDevice =
      ("ontouchstart" in window) ||
      (navigator.maxTouchPoints && navigator.maxTouchPoints > 0) ||
      window.matchMedia?.("(pointer: coarse)")?.matches;

    // joystick vector: x = right(+), y = forward(+)
    const joy = { active:false, pid:null, cx:0, cy:0, x:0, y:0, sprint:false };
    const joyRadius = 52; // px (stick travel)

    // touch-look
    const look = { active:false, pid:null, lastX:0, lastY:0 };

    if (isTouchDevice) {
      touchUI.classList.add("show");

      // Update hint for mobile (optional: hide desktop hint text)
      const hint = document.getElementById("hint");
      if (hint) hint.innerHTML = `Touch: <b>Left joystick</b> move ‚Ä¢ <b>Right drag</b> look ‚Ä¢ <b>Hold CHOP</b>`;

      // Prevent page scrolling while interacting
      document.body.style.overscrollBehavior = "none";
      document.body.style.touchAction = "none";
    } else {
      // Hide the mobile tip on desktop
      if (touchTip) touchTip.style.display = "none";
    }

    function setJoyFromPointer(px, py) {
      const dx = px - joy.cx;
      const dy = py - joy.cy;

      // clamp to radius
      const len = Math.hypot(dx, dy) || 1;
      const clampedLen = Math.min(len, joyRadius);
      const nx = (dx / len) * clampedLen;
      const ny = (dy / len) * clampedLen;

      // stick position
      joyStick.style.transform = `translate(${nx - 32}px, ${ny - 32}px)`; // 64px stick => -32 offset

      // normalized movement vector
      joy.x = nx / joyRadius;
      joy.y = -ny / joyRadius; // invert so up is forward

      // simple sprint when pushed far
      joy.sprint = (Math.hypot(joy.x, joy.y) > 0.88);
    }

    function resetJoy() {
      joy.active = false;
      joy.pid = null;
      joy.x = 0; joy.y = 0; joy.sprint = false;
      joyStick.style.transform = "translate(-32px, -32px)";
    }

    // Joystick pointer events
    joyBase?.addEventListener("pointerdown", (e) => {
      if (!isTouchDevice) return;
      e.preventDefault();

      initAudio(); // unlock audio on gesture
      joyBase.setPointerCapture(e.pointerId);

      const rect = joyBase.getBoundingClientRect();
      joy.active = true;
      joy.pid = e.pointerId;
      joy.cx = rect.left + rect.width * 0.5;
      joy.cy = rect.top + rect.height * 0.5;

      setJoyFromPointer(e.clientX, e.clientY);
    }, { passive:false });

    joyBase?.addEventListener("pointermove", (e) => {
      if (!joy.active || e.pointerId !== joy.pid) return;
      e.preventDefault();
      setJoyFromPointer(e.clientX, e.clientY);
    }, { passive:false });

    joyBase?.addEventListener("pointerup", (e) => {
      if (!joy.active || e.pointerId !== joy.pid) return;
      e.preventDefault();
      resetJoy();
    }, { passive:false });

    joyBase?.addEventListener("pointercancel", () => resetJoy());

    // Chop button (hold)
    function setChop(on) { isChopping = on; }
    chopBtn?.addEventListener("pointerdown", (e) => {
      if (!isTouchDevice) return;
      e.preventDefault();
      initAudio();
      chopBtn.setPointerCapture(e.pointerId);
      setChop(true);
    }, { passive:false });

    chopBtn?.addEventListener("pointerup", (e) => {
      if (!isTouchDevice) return;
      e.preventDefault();
      setChop(false);
    }, { passive:false });

    chopBtn?.addEventListener("pointercancel", () => setChop(false));

    // Touch-look: any drag on canvas NOT starting on UI controls
    function isOnTouchUI(target) {
      return target === joyBase || target === joyStick || target === chopBtn || joyBase?.contains(target) || chopBtn?.contains(target);
    }

    renderer.domElement.addEventListener("pointerdown", (e) => {
      if (!isTouchDevice) return;
      if (isOnTouchUI(e.target)) return;

      e.preventDefault();
      initAudio();

      look.active = true;
      look.pid = e.pointerId;
      look.lastX = e.clientX;
      look.lastY = e.clientY;

      renderer.domElement.setPointerCapture(e.pointerId);
    }, { passive:false });

    renderer.domElement.addEventListener("pointermove", (e) => {
      if (!isTouchDevice) return;
      if (!look.active || e.pointerId !== look.pid) return;

      e.preventDefault();
      const dx = e.clientX - look.lastX;
      const dy = e.clientY - look.lastY;
      look.lastX = e.clientX;
      look.lastY = e.clientY;

      // Similar feel to mouse sensitivity, tuned for touch
      const touchLookSensitivity = mouseSensitivity * 2.4;
      camYaw   -= dx * touchLookSensitivity;
      camPitch += dy * touchLookSensitivity;
      camPitch = Math.max(pitchMin, Math.min(pitchMax, camPitch));
    }, { passive:false });

    function endLook(e) {
      if (!look.active) return;
      if (e && e.pointerId !== look.pid) return;
      look.active = false;
      look.pid = null;
    }

    renderer.domElement.addEventListener("pointerup", endLook, { passive:false });
    renderer.domElement.addEventListener("pointercancel", endLook, { passive:false });


    // ---------- Audio (procedural WebAudio) ----------
    let audioCtx = null;
    let masterGain = null;

    function initAudio() {
      if (audioCtx) return;
      audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      masterGain = audioCtx.createGain();
      masterGain.gain.value = 0.25;
      masterGain.connect(audioCtx.destination);
    }

    function playChopSound() {
      if (!audioCtx) return;

      const t = audioCtx.currentTime;

      // Short "thunk": oscillator + quick envelope
      const osc = audioCtx.createOscillator();
      osc.type = "triangle";
      osc.frequency.setValueAtTime(180 + Math.random() * 60, t);
      osc.frequency.exponentialRampToValueAtTime(90 + Math.random() * 30, t + 0.06);

      const gain = audioCtx.createGain();
      gain.gain.setValueAtTime(0.0001, t);
      gain.gain.exponentialRampToValueAtTime(0.25 + Math.random() * 0.12, t + 0.01);
      gain.gain.exponentialRampToValueAtTime(0.0001, t + 0.09);

      // Add a little noise "crunch" for wood fibers
      const noise = audioCtx.createBufferSource();
      const buffer = audioCtx.createBuffer(1, audioCtx.sampleRate * 0.12, audioCtx.sampleRate);
      const data = buffer.getChannelData(0);
      for (let i = 0; i < data.length; i++) data[i] = (Math.random() * 2 - 1) * 0.6;
      noise.buffer = buffer;

      const noiseFilter = audioCtx.createBiquadFilter();
      noiseFilter.type = "bandpass";
      noiseFilter.frequency.setValueAtTime(900 + Math.random() * 400, t);
      noiseFilter.Q.setValueAtTime(1.5, t);

      const noiseGain = audioCtx.createGain();
      noiseGain.gain.setValueAtTime(0.0001, t);
      noiseGain.gain.exponentialRampToValueAtTime(0.10 + Math.random() * 0.06, t + 0.01);
      noiseGain.gain.exponentialRampToValueAtTime(0.0001, t + 0.08);

      osc.connect(gain);
      gain.connect(masterGain);

      noise.connect(noiseFilter);
      noiseFilter.connect(noiseGain);
      noiseGain.connect(masterGain);

      osc.start(t);
      osc.stop(t + 0.12);

      noise.start(t);
      noise.stop(t + 0.12);
    }

    function playTreeThud() {
      if (!audioCtx) return;
      const t = audioCtx.currentTime;

      const osc = audioCtx.createOscillator();
      osc.type = "sine";
      osc.frequency.setValueAtTime(80, t);
      osc.frequency.exponentialRampToValueAtTime(45, t + 0.18);

      const gain = audioCtx.createGain();
      gain.gain.setValueAtTime(0.0001, t);
      gain.gain.exponentialRampToValueAtTime(0.35, t + 0.01);
      gain.gain.exponentialRampToValueAtTime(0.0001, t + 0.25);

      osc.connect(gain);
      gain.connect(masterGain);

      osc.start(t);
      osc.stop(t + 0.28);
    }

    function playWoodPickupSound() {
      if (!audioCtx) return;
      const t = audioCtx.currentTime;

      // Bright rising "pop" for collecting wood
      const osc = audioCtx.createOscillator();
      osc.type = "sine";
      osc.frequency.setValueAtTime(660 + Math.random() * 180, t);
      osc.frequency.exponentialRampToValueAtTime(1320 + Math.random() * 200, t + 0.07);

      const gain = audioCtx.createGain();
      gain.gain.setValueAtTime(0.0001, t);
      gain.gain.exponentialRampToValueAtTime(0.18, t + 0.015);
      gain.gain.exponentialRampToValueAtTime(0.0001, t + 0.12);

      osc.connect(gain);
      gain.connect(masterGain);
      osc.start(t);
      osc.stop(t + 0.15);
    }


    // ---------- Helpers ----------
    const clock = new THREE.Clock();
    const raycaster = new THREE.Raycaster();
    const tmpV = new THREE.Vector3();
    const tmpV2 = new THREE.Vector3();
    const UP = new THREE.Vector3(0, 1, 0);
    const CIRCLE_FACE = new THREE.Vector3(0, 0, 1); // CircleGeometry normal

    // Pre-allocated temps to avoid per-frame garbage (#6)
    const _moveVec = new THREE.Vector3();
    const _camFwd = new THREE.Vector3();
    const _camRight = new THREE.Vector3();
    const _camOffset = new THREE.Vector3();
    const _desiredCam = new THREE.Vector3();
    const _fallQ = new THREE.Quaternion();
    const _wobbleAxis = new THREE.Vector3();
    const _wobbleQ = new THREE.Quaternion();
    const _projVec = new THREE.Vector3();

    // Raycast throttle (#8)
    let raycastFrame = 0;
    let cachedTarget = null;
    const RAYCAST_INTERVAL = 3;

    // Player collision radius
    const PLAYER_RADIUS = 0.45;
    const TREE_TRUNK_RADIUS = 0.35;

    function clamp01(x){ return Math.max(0, Math.min(1, x)); }
    function easeOutCubic(t){ return 1 - Math.pow(1 - t, 3); }

    // three r160-safe angle lerp (shortest path)
    function lerpAngle(a, b, t) {
      const TWO_PI = Math.PI * 2;
      let delta = (b - a) % TWO_PI;
      if (delta > Math.PI) delta -= TWO_PI;
      if (delta < -Math.PI) delta += TWO_PI;
      return a + delta * t;
    }

    // ---------- Floating "+1" text (#4) ----------
    const floatTexts = [];

    function spawnFloatText(worldPos, text) {
      const el = document.createElement("div");
      el.className = "floatText";
      el.textContent = text;
      document.body.appendChild(el);
      floatTexts.push({
        el,
        wx: worldPos.x, wy: worldPos.y + 1.5, wz: worldPos.z,
        life: 1.0,
        maxLife: 1.0,
        offsetY: 0
      });
    }

    function updateFloatTexts(dt) {
      for (let i = floatTexts.length - 1; i >= 0; i--) {
        const ft = floatTexts[i];
        ft.life -= dt;
        ft.offsetY += dt * 1.8;
        if (ft.life <= 0) {
          ft.el.remove();
          floatTexts.splice(i, 1);
          continue;
        }
        _projVec.set(ft.wx, ft.wy + ft.offsetY, ft.wz);
        _projVec.project(camera);
        if (_projVec.z > 1) { ft.el.style.display = "none"; continue; }
        ft.el.style.display = "";
        const sx = ( _projVec.x * 0.5 + 0.5) * window.innerWidth;
        const sy = (-_projVec.y * 0.5 + 0.5) * window.innerHeight;
        ft.el.style.left = sx + "px";
        ft.el.style.top  = sy + "px";
        ft.el.style.opacity = String(ft.life / ft.maxLife);
        ft.el.style.transform = "translate(-50%,-50%)";
      }
    }

    // ---------- Collision (trees & rocks) ----------
    function resolveCollisions() {
      for (const tree of trees) {
        if (!tree.userData.alive || tree.userData.falling) continue;
        const dx = player.position.x - tree.position.x;
        const dz = player.position.z - tree.position.z;
        const dist = Math.hypot(dx, dz);
        const minDist = PLAYER_RADIUS + TREE_TRUNK_RADIUS * tree.scale.x;
        if (dist < minDist && dist > 0.001) {
          const push = (minDist - dist) / dist;
          player.position.x += dx * push;
          player.position.z += dz * push;
        }
      }
      for (const rock of rockColliders) {
        const dx = player.position.x - rock.x;
        const dz = player.position.z - rock.z;
        const dist = Math.hypot(dx, dz);
        const minDist = PLAYER_RADIUS + rock.radius;
        if (dist < minDist && dist > 0.001) {
          const push = (minDist - dist) / dist;
          player.position.x += dx * push;
          player.position.z += dz * push;
        }
      }
    }

    // ---------- Clouds (#13) ----------
    const clouds = [];
    (function createClouds() {
      const cloudMat = new THREE.MeshBasicMaterial({
        color: 0xffffff, transparent: true, opacity: 0.7
      });
      for (let i = 0; i < 14; i++) {
        const cloud = new THREE.Group();
        const puffs = 3 + Math.floor(Math.random() * 3);
        for (let j = 0; j < puffs; j++) {
          const sz = 3 + Math.random() * 5;
          const puff = new THREE.Mesh(
            new THREE.SphereGeometry(sz, 8, 6), cloudMat
          );
          puff.position.set(
            (Math.random() - 0.5) * 10,
            (Math.random() - 0.5) * 2,
            (Math.random() - 0.5) * 5
          );
          puff.scale.y = 0.35 + Math.random() * 0.25;
          cloud.add(puff);
        }
        cloud.position.set(
          (Math.random() - 0.5) * 400,
          55 + Math.random() * 40,
          (Math.random() - 0.5) * 400
        );
        cloud.userData.speed = 1.5 + Math.random() * 2.5;
        cloud.userData.dir = Math.random() > 0.5 ? 1 : -1;
        scene.add(cloud);
        clouds.push(cloud);
      }
    })();

    function updateClouds(dt) {
      for (const c of clouds) {
        c.position.x += c.userData.speed * c.userData.dir * dt;
        if (c.position.x >  250) c.position.x = -250;
        if (c.position.x < -250) c.position.x =  250;
      }
    }

    // ---------- Particles (woodchips + leaves) ----------
    const particles = []; // { mesh, v, life, maxLife, spin, drag, gravity, groundBounce, type }

    const woodChipMat = new THREE.MeshStandardMaterial({ color: 0x9a6b3a, roughness: 1 });
    const leafMat     = new THREE.MeshStandardMaterial({ color: 0x2f7d46, roughness: 1, side: THREE.DoubleSide });

    const woodChipGeo = new THREE.BoxGeometry(0.06, 0.02, 0.02);
    const leafGeo     = new THREE.PlaneGeometry(0.08, 0.10);

    // ---------- Particle pool (#7) ----------
    const chipPool = [];
    const leafPool = [];
    const POOL_MAX = 80;

    function getPooledMesh(type) {
      const pool = type === "chip" ? chipPool : type === "leaf" ? leafPool : null;
      if (pool && pool.length > 0) {
        const m = pool.pop();
        m.material.opacity = 1;
        m.material.transparent = false;
        return m;
      }
      if (type === "chip") return new THREE.Mesh(woodChipGeo, woodChipMat.clone());
      if (type === "leaf") return new THREE.Mesh(leafGeo, leafMat.clone());
      return null;
    }

    function releasePooledMesh(mesh, type) {
      const pool = type === "chip" ? chipPool : type === "leaf" ? leafPool : null;
      if (pool && pool.length < POOL_MAX) pool.push(mesh);
    }

    // ---------- "White puddle" splat ----------
    const puddleMat = new THREE.MeshBasicMaterial({
      color: 0xffffff,
      transparent: true,
      opacity: 0.95,
      depthWrite: false
    });
    const puddleGeo = new THREE.CircleGeometry(1, 40);

    function spawnWhitePuddleExplosion(tree) {
      // Base position near the tree trunk on the ground
      const baseX = tree.position.x;
      const baseZ = tree.position.z;

      // Main puddle
      {
        const m = new THREE.Mesh(puddleGeo, puddleMat.clone());
        const y = getGroundHeight(baseX, baseZ) + 0.02;
        m.position.set(baseX, y, baseZ);
        // Align to ground slope so puddle doesn't clip terrain (#12)
        const pn = getGroundNormal(baseX, baseZ);
        m.quaternion.setFromUnitVectors(CIRCLE_FACE, pn);

        // Start small, expand fast
        const endScale = 3.0 + Math.random() * 2.5;
        m.scale.set(0.12, 0.12, 0.12);

        scene.add(m);
        particles.push({
          mesh: m,
          v: new THREE.Vector3(0, 0, 0),
          life: 7.0,
          maxLife: 7.0,
          spin: new THREE.Vector3(0, 0, 0),
          drag: 1,
          gravity: 0,
          groundBounce: 0,
          type: "puddle",
          startScale: 0.08,
          endScale,
          slopeQuat: m.quaternion.clone()
        });
      }

      // Droplets (small splats around it)
      const drops = 7 + Math.floor(Math.random() * 6);
      for (let i = 0; i < drops; i++) {
        const m = new THREE.Mesh(puddleGeo, puddleMat.clone());
        m.material.opacity = 0.85;

        const r = 1.4 + Math.random() * 3.0;
        const a = Math.random() * Math.PI * 2;
        const x = baseX + Math.cos(a) * r;
        const z = baseZ + Math.sin(a) * r;
        const y = getGroundHeight(x, z) + 0.02;

        m.position.set(x, y, z);
        // Align droplet to ground slope
        const dn = getGroundNormal(x, z);
        m.quaternion.setFromUnitVectors(CIRCLE_FACE, dn);

        const endScale = 0.6 + Math.random() * 1.1;
        m.scale.set(0.08, 0.08, 0.08);

        scene.add(m);
        const dropletLife = 4.5 + Math.random() * 2.0;

        particles.push({
          mesh: m,
          v: new THREE.Vector3(0, 0, 0),
          life: dropletLife,
          maxLife: dropletLife,
          spin: new THREE.Vector3(0, 0, 0),
          drag: 1,
          gravity: 0,
          groundBounce: 0,
          type: "puddle",
          startScale: 0.05,
          endScale,
          slopeQuat: m.quaternion.clone()
        });
      }
    }

    function spawnChopParticles(tree) {
      // spawn at about chest height near trunk
      const origin = tree.position.clone();
      origin.y = tree.position.y + 1.2;

      // determine a direction from player -> tree (chips fly away from trunk face)
      tmpV.copy(tree.position).sub(player.position);
      tmpV.y = 0;
      if (tmpV.lengthSq() < 0.0001) tmpV.set(0, 0, 1);
      tmpV.normalize();

      // --- woodchips (fast) ---
      const chipCount = 10 + Math.floor(Math.random() * 8);
      for (let i = 0; i < chipCount; i++) {
        const m = getPooledMesh("chip");
        m.position.copy(origin);
        m.position.x += (Math.random() - 0.5) * 0.18;
        m.position.y += (Math.random() - 0.5) * 0.20;
        m.position.z += (Math.random() - 0.5) * 0.18;

        // velocity: mostly outward + up
        const v = new THREE.Vector3(
          tmpV.x * (2.0 + Math.random() * 2.5) + (Math.random() - 0.5) * 1.5,
          2.0 + Math.random() * 2.5,
          tmpV.z * (2.0 + Math.random() * 2.5) + (Math.random() - 0.5) * 1.5
        );

        m.rotation.set(Math.random() * Math.PI, Math.random() * Math.PI, Math.random() * Math.PI);

        scene.add(m);
        particles.push({
          mesh: m,
          v,
          life: 0.45 + Math.random() * 0.25,
          maxLife: 0.7,
          spin: new THREE.Vector3((Math.random()-0.5)*14, (Math.random()-0.5)*14, (Math.random()-0.5)*14),
          drag: 0.88,
          gravity: -12.0,
          groundBounce: 0.25,
          type: "chip"
        });
      }

      // --- leaves (slow + floaty) ---
      const leafCount = 6 + Math.floor(Math.random() * 6);
      for (let i = 0; i < leafCount; i++) {
        const m = getPooledMesh("leaf");
        m.position.copy(origin);
        m.position.y += 1.3 + Math.random() * 0.8; // originate higher
        m.position.x += (Math.random() - 0.5) * 0.9;
        m.position.z += (Math.random() - 0.5) * 0.9;

        // leaves drift down
        const v = new THREE.Vector3(
          (Math.random() - 0.5) * 0.8 + tmpV.x * 0.3,
          -0.2 - Math.random() * 0.6,
          (Math.random() - 0.5) * 0.8 + tmpV.z * 0.3
        );

        m.rotation.set(0, Math.random() * Math.PI * 2, Math.random() * Math.PI * 2);

        scene.add(m);
        particles.push({
          mesh: m,
          v,
          life: 1.6 + Math.random() * 1.1,
          maxLife: 2.8,
          spin: new THREE.Vector3((Math.random()-0.5)*3, (Math.random()-0.5)*2, (Math.random()-0.5)*6),
          drag: 0.985,
          gravity: -1.0,
          groundBounce: 0.0,
          type: "leaf"
        });
      }
    }

    function updateParticles(dt) {
      for (let i = particles.length - 1; i >= 0; i--) {
        const p = particles[i];

        // integrate
        p.v.y += p.gravity * dt;
        p.v.multiplyScalar(Math.pow(p.drag, dt * 60));

        p.mesh.position.addScaledVector(p.v, dt);

        // spin (skip puddles ‚Äî they use quaternion alignment)
        if (p.type !== "puddle") {
          p.mesh.rotation.x += p.spin.x * dt;
          p.mesh.rotation.y += p.spin.y * dt;
          p.mesh.rotation.z += p.spin.z * dt;
        }

        // ground
        const gy = getGroundHeight(p.mesh.position.x, p.mesh.position.z) + 0.02;
        if (p.mesh.position.y < gy) {
          p.mesh.position.y = gy;
          if (p.groundBounce > 0) {
            p.v.y = Math.abs(p.v.y) * p.groundBounce;
            p.v.x *= 0.75;
            p.v.z *= 0.75;
          } else {
            // leaves just rest
            p.v.set(0, 0, 0);
          }
        }

        // life/fade
        p.life -= dt;

        // Default alpha for most particles
        let alpha = Math.max(0, Math.min(1, p.life / p.maxLife));

        // Special behavior: puddles expand quickly then fade
        if (p.type === "puddle") {
          const lifeFrac = Math.max(0, Math.min(1, p.life / p.maxLife)); // 1..0
          const t = 1 - lifeFrac; // 0..1 over lifetime

          // Spread slowly over most of lifetime
          const hold = 0.10;
          const spreadPortion = 0.85;
          const tt = (t - hold) / spreadPortion;
          const grow = easeOutCubic(Math.max(0, Math.min(1, tt)));

          const s = p.startScale + (p.endScale - p.startScale) * grow;
          p.mesh.scale.set(s, s, s);

          // Align to stored ground slope quaternion (#12)
          if (p.slopeQuat) p.mesh.quaternion.copy(p.slopeQuat);

          // Pin to ground
          p.mesh.position.y = getGroundHeight(p.mesh.position.x, p.mesh.position.z) + 0.02;

          // Fade VERY slowly, mostly at the end
          const fadeStart = 0.70; // don't really fade until 70% of lifetime has passed
          const fadeT = Math.max(0, Math.min(1, (t - fadeStart) / (1 - fadeStart)));
          alpha = 1 - (fadeT * fadeT * (3 - 2 * fadeT)); // smoothstep fade
        }

        // quick fade on chips (material transparency)
        if (p.type === "chip") {
          p.mesh.material.transparent = true;
          p.mesh.material.opacity = alpha;
        } else {
          p.mesh.material.transparent = true;
          p.mesh.material.opacity = alpha;
        }

        if (p.life <= 0) {
          scene.remove(p.mesh);
          if (p.type === "chip" || p.type === "leaf") releasePooledMesh(p.mesh, p.type);
          particles.splice(i, 1);
        }
      }
    }



    // ---------- Trees ----------
    const trees = [];
    const treeGroup = new THREE.Group();
    scene.add(treeGroup);

    // For raycast, we keep a list of mesh objects that belong to trees
    const treePickMeshes = [];

    function makeTree(name) {
      const g = new THREE.Group();
      g.name = name;
      g.userData.isTree = true;

      // trunk (bottom sits on y=0 because trunk height=2 and centered at y=1)
      const trunk = new THREE.Mesh(
        new THREE.CylinderGeometry(0.25, 0.35, 2.0, 8),
        new THREE.MeshStandardMaterial({ color: 0x6b4a2b, roughness: 1 })
      );
      trunk.position.y = 1.0;
      trunk.userData.treeRoot = g;
      g.add(trunk);

      // leaves
      const leaves = new THREE.Mesh(
        new THREE.ConeGeometry(1.2, 2.8, 10),
        new THREE.MeshStandardMaterial({ color: 0x2f7d46, roughness: 1 })
      );
      leaves.position.y = 3.0;
      leaves.userData.treeRoot = g;
      g.add(leaves);

      // Raycast candidates
      treePickMeshes.push(trunk, leaves);

      // chop + fall state
      g.userData.hp = 1.0;          // 0..1
      g.userData.maxHp = 1.0;
      g.userData.alive = true;

      g.userData.falling = false;
      g.userData.fallT = 0;         // 0..1 over fall duration
      g.userData.fallAxis = new THREE.Vector3(1,0,0);
      g.userData.fallAngle = 0;
      g.userData.removeAt = null;   // time in seconds (clock) to remove after hitting ground

      return g;
    }

    function scatterTrees(count = 70) {
      for (let i = 0; i < count; i++) {
        const t = makeTree("Tree " + (i + 1));
        const x = (Math.random() - 0.5) * 140;
        const z = (Math.random() - 0.5) * 140;

        if (Math.hypot(x, z) < 10) { i--; continue; }

        // Sit tree base on terrain
        const y = getGroundHeight(x, z);
        const n = getGroundNormal(x, z);

        t.position.set(x, y, z);

        // Align tree "up" to slope normal
        t.quaternion.setFromUnitVectors(new THREE.Vector3(0, 1, 0), n);

        // Random twist around the slope normal (so forests don‚Äôt look uniform)
        t.quaternion.premultiply(new THREE.Quaternion().setFromAxisAngle(n, Math.random() * Math.PI * 2));

        // Save the aligned "resting" rotation so wobble/fall can be applied relative to it
        t.userData.baseQuat = t.quaternion.clone();

        const s = 1.2 + Math.random() * 0.8; // bigger trees
        t.scale.set(s, s, s);

        treeGroup.add(t);
        trees.push(t);
      }
    }
    scatterTrees(70);

    // ---------- Wood drops ----------
    const woodDrops = [];
    const woodGroup = new THREE.Group();
    scene.add(woodGroup);

    function spawnWoodDrops(tree, fallDir) {
      const dropCount = 2 + Math.floor(Math.random() * 3); // 2..4
      const logMat = new THREE.MeshStandardMaterial({ color: 0x8a5a34, roughness: 1 });

      for (let i = 0; i < dropCount; i++) {
        const log = new THREE.Mesh(
          new THREE.CylinderGeometry(0.12, 0.12, 0.45, 8),
          logMat
        );
        log.rotation.z = Math.PI * 0.5;
        log.position.copy(tree.position);
        log.position.y = tree.position.y + 0.25;
        log.position.addScaledVector(fallDir, 0.6 + Math.random() * 0.8);
        log.position.x += (Math.random() - 0.5) * 0.4;
        log.position.z += (Math.random() - 0.5) * 0.4;

        // simple velocity + gravity
        const v = new THREE.Vector3(
          (Math.random() - 0.5) * 1.2 + fallDir.x * (0.5 + Math.random()),
          2.2 + Math.random() * 1.2,
          (Math.random() - 0.5) * 1.2 + fallDir.z * (0.5 + Math.random())
        );

        log.userData.v = v;
        log.userData.collected = false;

        woodGroup.add(log);
        woodDrops.push(log);
      }
    }

    function updateWoodDrops(dt) {
      const gravity = -8.5;

      for (let i = woodDrops.length - 1; i >= 0; i--) {
        const d = woodDrops[i];
        if (d.userData.collected) continue;

        // physics-lite
        d.userData.v.y += gravity * dt;
        d.position.addScaledVector(d.userData.v, dt);

        // ground collide
        const gy = getGroundHeight(d.position.x, d.position.z) + 0.18;
        if (d.position.y < gy) {
          d.position.y = gy;
          d.userData.v.y *= -0.25; // small bounce
          d.userData.v.x *= 0.82;
          d.userData.v.z *= 0.82;

          // stop jitter
          if (Math.abs(d.userData.v.y) < 0.2) d.userData.v.y = 0;
        }

        // spin a bit
        d.rotation.x += dt * 1.8;
        d.rotation.y += dt * 1.1;

        // auto-collect if close to player
        tmpV.copy(d.position).sub(player.position);
        tmpV.y = 0;
        if (tmpV.length() < 1.15 * pickupRadiusMultiplier) {
          const gain = doubleDropActive ? 2 : 1;
          spawnFloatText(d.position, `+${gain} Wood`);
          playWoodPickupSound();

          d.userData.collected = true;
          woodGroup.remove(d);
          woodDrops.splice(i, 1);

          wood += gain;
          woodEl.textContent = String(wood);
        }
      }
    }

    // ---------- Targeting (center-screen raycast) ----------
    function pickTreeFromCenter() {
      raycaster.setFromCamera({ x: 0, y: 0 }, camera);
      const hits = raycaster.intersectObjects(treePickMeshes, false);

      if (!hits.length) return null;

      // find first alive tree within range
      const maxDist = 5.0;

      for (const h of hits) {
        const root = h.object.userData.treeRoot;
        if (!root) continue;
        if (!root.userData.alive) continue;
        if (root.userData.falling) continue;

        // distance check from player to tree base
        tmpV.copy(root.position).sub(player.position);
        tmpV.y = 0;
        if (tmpV.length() <= maxDist) return root;
      }

      return null;
    }

    // ---------- Chopping + falling ----------
    const BASE_CHOP_RATE = 0.60; // hp per second
    // chopRate is now computed dynamically via chopMultiplier
    const fallDuration = 0.65; // seconds
    const removeDelayAfterFall = 1.1;
    // Chop "hit" cadence (visual + sound)
    let chopHitTimer = 0;
    const chopHitInterval = 0.12; // seconds between bursts while holding
    let lastWobbleTree = null;



    function startTreeFall(tree) {
      tree.userData.falling = true;
      tree.userData.fallT = 0;
      tree.userData.fallAngle = 0;

      // Fall direction AWAY from player (tree -> away direction)
      tmpV.copy(tree.position).sub(player.position);
      tmpV.y = 0;
      if (tmpV.lengthSq() < 0.0001) tmpV.set(1, 0, 0);
      tmpV.normalize(); // this points from player to tree, so "away from player" for the tree top

      // Axis to rotate around so the tree tips in tmpV direction:
      // rotate around axis perpendicular to UP and fallDir.
      tmpV2.crossVectors(UP, tmpV).normalize();
      if (tmpV2.lengthSq() < 0.0001) tmpV2.set(0, 0, 1);

      tree.userData.fallAxis.copy(tmpV2);

      // Ensure we have a base rotation snapshot
      if (!tree.userData.baseQuat) tree.userData.baseQuat = tree.quaternion.clone();

      // Spawn wood after impact (we‚Äôll do it when fall completes)
      tree.userData.fallDir = tmpV.clone();
    }

    function updateFallingTrees(dt, nowSeconds) {
      for (let i = trees.length - 1; i >= 0; i--) {
        const t = trees[i];
        if (!t.userData.alive) continue;

        if (t.userData.falling) {
          t.userData.fallT = Math.min(1, t.userData.fallT + dt / fallDuration);
          const eased = easeOutCubic(t.userData.fallT);

          const targetAngle = Math.PI / 2; // 90 degrees
          const angle = eased * targetAngle;
          t.userData.fallAngle = angle;

          // Apply fall rotation relative to the tree's base (slope-aligned) rotation
          _fallQ.setFromAxisAngle(t.userData.fallAxis, angle);
          t.quaternion.copy(t.userData.baseQuat).multiply(_fallQ);

          // when impact happens (fallT hits 1), schedule removal + spawn wood once
          if (t.userData.fallT >= 1 && t.userData.removeAt == null) {
            t.userData.removeAt = nowSeconds + removeDelayAfterFall;

            // drop wood in the direction it fell
            playTreeThud();
            spawnWoodDrops(t, t.userData.fallDir || new THREE.Vector3(1,0,0));

            // 1/10 chance: impact "white puddle" splat
            if (Math.random() < (1/3)) {
              spawnWhitePuddleExplosion(t);
            }
          }

          // remove after delay
          if (t.userData.removeAt != null && nowSeconds >= t.userData.removeAt) {
            t.userData.alive = false;
            treeGroup.remove(t);
          }
        }
      }
    }

    // ---------- Movement tuning ----------
    const BASE_SPEED = 6.0;
    const BASE_SPRINT = 10.0;
    const turnSpeed = 12.0;

    // ---------- Jump / gravity ----------
    let playerVy = 0;                // vertical velocity
    let isGrounded = false;
    const jumpSpeed = 6.4;           // jump impulse
    const gravity = -18.0;           // downward accel (units/s^2)


    // --- Mouse-look (pointer lock) ---
    let camYaw = 0;                  // left/right
    let camPitch = -0.35;            // up/down (radians)
    const pitchMin = -1.15;          // can look further down
    const pitchMax = 0.85;           // can look much further up
    const mouseSensitivity = 0.0022;

    // Click to lock pointer (required by browser)
    renderer.domElement.addEventListener("click", () => {
      // Don't pointer-lock if the donation modal is still open
      if (typeof modalOpen !== "undefined" && modalOpen) return;

      renderer.domElement.focus(); // <-- critical for WASD
      initAudio();
      renderer.domElement.requestPointerLock?.();
    });

    // Update yaw/pitch when pointer is locked
    window.addEventListener("mousemove", (e) => {
      if (document.pointerLockElement !== renderer.domElement) return;

      camYaw   -= e.movementX * mouseSensitivity;
      camPitch += e.movementY * mouseSensitivity; // inverted Y
      camPitch = Math.max(pitchMin, Math.min(pitchMax, camPitch));
    });



    // ---------- Game loop ----------
    function animate() {
      requestAnimationFrame(animate);
      
      try {
      const dt = Math.min(clock.getDelta(), 0.05);
      const nowSeconds = clock.elapsedTime;

      // --- Movement (camera-relative) ---
      const sprint = (keys.has("ShiftLeft") || keys.has("ShiftRight")) || (isTouchDevice && joy.sprint);
      const speed = (sprint ? BASE_SPRINT : BASE_SPEED) * speedMultiplier;

      _moveVec.set(0, 0, 0);
      _camFwd.set(-Math.sin(camYaw), 0, -Math.cos(camYaw)).normalize();
      _camRight.crossVectors(_camFwd, UP).normalize();

      // Keyboard
      if (keys.has("KeyW")) _moveVec.add(_camFwd);
      if (keys.has("KeyS")) _moveVec.sub(_camFwd);
      if (keys.has("KeyA")) _moveVec.sub(_camRight);
      if (keys.has("KeyD")) _moveVec.add(_camRight);

      // Touch joystick
      if (isTouchDevice && (joy.x !== 0 || joy.y !== 0)) {
        _moveVec.addScaledVector(_camRight, joy.x);
        _moveVec.addScaledVector(_camFwd, joy.y);
      }

      if (_moveVec.lengthSq() > 0) {
        _moveVec.normalize();

        // Rotate player to face movement direction (camera-relative)
        const targetYaw = Math.atan2(_moveVec.x, _moveVec.z);
        player.rotation.y = lerpAngle(
          player.rotation.y,
          targetYaw,
          Math.min(1, turnSpeed * dt)
        );

        player.position.addScaledVector(_moveVec, speed * dt);
      }

      // --- Collision with trees & rocks ---
      resolveCollisions();

      // Ground height under player (terrain)
      const groundY = getGroundHeight(player.position.x, player.position.z);

      // Jump (Space) only when grounded
      if (keys.has("Space") && isGrounded) {
        playerVy = jumpSpeed;
        isGrounded = false;
      }

      // Gravity integration
      playerVy += gravity * dt;
      player.position.y += playerVy * dt;

      // Ground collision / landing
      if (player.position.y <= groundY) {
        player.position.y = groundY;
        playerVy = 0;
        isGrounded = true;
      }

      // --- Camera (mouse-look orbit behind player) ---
      const camDistance = 10;
      const camHeight = 2.2;

      _camOffset.set(
        Math.sin(camYaw) * Math.cos(camPitch),
        Math.sin(camPitch),
        Math.cos(camYaw) * Math.cos(camPitch)
      ).multiplyScalar(camDistance);

      _desiredCam.copy(player.position).add(_camOffset);
      _desiredCam.y += camHeight;

      // --- Camera ground collision (terrain-aware #14) ---
      const camGroundY = getGroundHeight(_desiredCam.x, _desiredCam.z) + 1.0;
      _desiredCam.y = Math.max(camGroundY, _desiredCam.y);

      // Smooth camera
      camera.position.lerp(_desiredCam, 1 - Math.pow(0.001, dt));

      // Look at player (slightly above center)
      camera.lookAt(player.position.x, player.position.y + 1.2, player.position.z);

      // --- Targeting (throttled raycast #8) ---
      raycastFrame++;
      if (raycastFrame >= RAYCAST_INTERVAL || isChopping) {
        raycastFrame = 0;
        cachedTarget = pickTreeFromCenter();
      }
      const target = cachedTarget;
      targetNameEl.textContent = target ? target.name : "None";

      // Reticle color (#5)
      if (target) {
        centerDot.classList.add("targeting");
      } else {
        centerDot.classList.remove("targeting");
      }

      // --- Chopping ---
      if (target && isChopping) {
        target.userData.hp = clamp01(target.userData.hp - BASE_CHOP_RATE * chopMultiplier * dt);

        // Wiggle the axe
        axe.rotation.z = Math.sin(performance.now() * 0.05) * 0.6;

        // If we switched targets, reset the old tree so it doesn't stay tilted
        if (lastWobbleTree && lastWobbleTree !== target && !lastWobbleTree.userData.falling && lastWobbleTree.userData.baseQuat) {
          lastWobbleTree.quaternion.copy(lastWobbleTree.userData.baseQuat);
        }
        lastWobbleTree = target;

        // Apply wobble only to non-falling trees
        if (!target.userData.falling) {
          if (!target.userData.baseQuat) target.userData.baseQuat = target.quaternion.clone();
          const wobble = Math.sin(performance.now() * 0.03) * 0.06;
          _wobbleAxis.set(1, 0, 0).applyQuaternion(target.userData.baseQuat).normalize();
          _wobbleQ.setFromAxisAngle(_wobbleAxis, wobble);
          target.quaternion.copy(target.userData.baseQuat).multiply(_wobbleQ);
        }

        // Trigger particles + sound at a steady "axe hit" rhythm
        chopHitTimer -= dt;
        if (chopHitTimer <= 0) {
          chopHitTimer = chopHitInterval;

          spawnChopParticles(target);
          playChopSound();
        }

        if (target.userData.hp <= 0 && !target.userData.falling) {
          score += 1;
          scoreEl.textContent = String(score);
          startTreeFall(target);
          chopHitTimer = 0;
        }
      } else {
        axe.rotation.z = 0;
        if (lastWobbleTree && lastWobbleTree.userData.baseQuat && !lastWobbleTree.userData.falling) {
          lastWobbleTree.quaternion.copy(lastWobbleTree.userData.baseQuat);
        }
        chopHitTimer = 0;
        lastWobbleTree = null;
      }

      // Update chop bar
      if (target) {
        const pct = (1 - (target.userData.hp / target.userData.maxHp)) * 100;
        barInner.style.width = `${pct.toFixed(1)}%`;
      } else {
        barInner.style.width = `0%`;
      }

      // --- Update systems ---
      updateFallingTrees(dt, nowSeconds);

      if (!modalOpen && nowSeconds >= nextDonationAt) {
        openDonationModal();
        scheduleNextDonation(nowSeconds);
      }

      updateVendor(dt);
      updateWoodDrops(dt);
      updateParticles(dt);
      updateClouds(dt);
      updateFloatTexts(dt);

      renderer.render(scene, camera);

      } catch (err) {
        console.error(err);
        const hud = document.getElementById("hud");
        if (hud) {
          hud.innerHTML = `
            <div style="font-weight:800;color:#ffb4b4">Runtime error</div>
            <div style="font-size:12px;white-space:pre-wrap">${String(err)}</div>
          `;
        }
      }
    }

    animate();      


    // ---------- Resize ----------
    window.addEventListener("resize", () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
  </script>
</body>
</html>
