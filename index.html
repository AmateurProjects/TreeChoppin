<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,minimum-scale=1,maximum-scale=1,user-scalable=no,viewport-fit=cover" />
  <title>Tree Chopping Prototype</title>
  <style>
    html, body { margin:0; padding:0; overflow:hidden; background:#0b0f12; }
    canvas { display:block; }

    /* Prevent selection/highlight/callout on mobile */
    html, body {
      -webkit-user-select: none;
      user-select: none;
      -webkit-touch-callout: none; /* iOS long-press menu */
      -webkit-tap-highlight-color: transparent;
    }

    /* Still allow selecting text inside the HUD if you ever want to copy; optional */
    /* #hud { -webkit-user-select: none; user-select: none; } */

    /* Minimal HUD */
    #hud {
      position: fixed;
      left: 12px; top: 12px;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      color: #e8f0f7;
      user-select: none;
      background: rgba(0,0,0,0.35);
      padding: 10px 12px;
      border-radius: 12px;
      backdrop-filter: blur(6px);
      max-width: 340px;
    }
    #hint { font-size: 12px; opacity: 0.9; margin-top: 6px; line-height: 1.3; }
    .statline { margin-top: 6px; font-size: 13px; }
    #score, #wood { font-weight: 800; }

    #chopWrap { margin-top: 10px; }
    #barOuter {
      width: 260px; height: 10px;
      border-radius: 999px;
      background: rgba(255,255,255,0.12);
      overflow: hidden;
    }
    #barInner {
      width: 0%;
      height: 100%;
      background: rgba(120, 220, 120, 0.95);
    }
    #targetLine { font-size: 12px; margin-top: 6px; opacity: 0.9; }
    #centerDot {
      position: fixed; left: 50%; top: 50%;
      width: 6px; height: 6px;
      transform: translate(-50%, -50%);
      border-radius: 50%;
      background: rgba(255,255,255,0.7);
      box-shadow: 0 0 0 3px rgba(0,0,0,0.25);
      pointer-events: none;
    }
    /* ---------- Touch controls (mobile) ---------- */
    .touch-ui {
      position: fixed;
      inset: 0;
      pointer-events: none;
      z-index: 10;
    }
    .touch-ui.show { display: block; }
    .touch-ui { display: none; }

    .touch-joystick {
      position: fixed;
      left: 18px;
      bottom: 18px;
      width: 140px;
      height: 140px;
      border-radius: 999px;
      background: rgba(0,0,0,0.25);
      border: 1px solid rgba(255,255,255,0.18);
      backdrop-filter: blur(6px);
      pointer-events: auto;
      touch-action: none;
    }
    .touch-joystick .stick {
      position: absolute;
      left: 50%;
      top: 50%;
      width: 64px;
      height: 64px;
      border-radius: 999px;
      transform: translate(-50%, -50%);
      background: rgba(255,255,255,0.18);
      border: 1px solid rgba(255,255,255,0.22);
      box-shadow: 0 10px 24px rgba(0,0,0,0.25);
    }

    .touch-chop {
      position: fixed;
      right: 18px;
      bottom: 18px;
      width: 108px;
      height: 108px;
      border-radius: 999px;
      background: rgba(255,255,255,0.12);
      border: 1px solid rgba(255,255,255,0.22);
      color: #e8f0f7;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      font-weight: 800;
      letter-spacing: 0.2px;
      pointer-events: auto;
      touch-action: none;
      user-select: none;
      -webkit-user-select: none;
      display: grid;
      place-items: center;
      backdrop-filter: blur(6px);
    }

    .touch-tip {
      position: fixed;
      left: 12px;
      right: 12px;
      bottom: 170px;
      text-align: center;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      color: rgba(232,240,247,0.85);
      font-size: 12px;
      pointer-events: none;
      text-shadow: 0 2px 10px rgba(0,0,0,0.45);
    }

    /* ---------- Modal overlay ---------- */
    .modalOverlay{
      position: fixed;
      inset: 0;
      display: grid;
      place-items: center;
      background: rgba(0,0,0,0.55);
      backdrop-filter: blur(8px);
      z-index: 999;          /* above HUD + touch UI */
      pointer-events: auto;
      touch-action: none;    /* prevent scroll/zoom while modal open */
    }

    .modalCard{
      width: min(520px, calc(100vw - 32px));
      background: rgba(16, 22, 28, 0.92);
      border: 1px solid rgba(255,255,255,0.14);
      border-radius: 18px;
      box-shadow: 0 18px 70px rgba(0,0,0,0.45);
      padding: 18px 18px 14px;
      color: #e8f0f7;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
    }

    .modalTitle{
      font-weight: 900;
      font-size: 18px;
      line-height: 1.25;
      margin-bottom: 14px;
    }

    .modalRow{
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .modalBtn{
      border: 1px solid rgba(255,255,255,0.16);
      background: rgba(255,255,255,0.10);
      color: #e8f0f7;
      border-radius: 14px;
      padding: 12px 16px;
      font-weight: 900;
      cursor: pointer;
      user-select: none;
      -webkit-user-select: none;
      touch-action: none;
    }
    .modalBtn:active{
      transform: translateY(1px);
    }

    .modalBtnPlus{
      width: 56px;
      height: 56px;
      font-size: 26px;
      display: grid;
      place-items: center;
    }

    .modalValue{
      min-width: 92px;
      font-size: 20px;
      font-weight: 900;
      padding: 10px 12px;
      border-radius: 14px;
      background: rgba(0,0,0,0.22);
      border: 1px solid rgba(255,255,255,0.10);
      text-align: center;
    }

    .modalSpacer{
      flex: 1;
    }

    .modalBtnPlay{
      min-width: 110px;
      height: 56px;
      font-size: 16px;
    }

    .modalBtn:disabled{
      opacity: 0.45;
      cursor: not-allowed;
      transform: none;
    }

    .modalSubtext{
      margin-top: 10px;
      font-size: 12px;
      opacity: 0.85;
    }

    .modalHidden{
      display: none !important;
    }

    #donationModal, .touch-ui, .touch-joystick, .touch-chop, .modalBtn, .modalCard {
      -webkit-user-select: none;
      user-select: none;
      -webkit-touch-callout: none;
      -webkit-tap-highlight-color: transparent;
    }




  </style>
</head>
<body>
  <div id="hud">
    <div class="statline">Score: <span id="score">0</span> &nbsp;•&nbsp; Wood: <span id="wood">0</span></div>
    <div id="hint">
      Move: <b>WASD</b> • Sprint: <b>Shift</b> • Chop: <b>Hold Left Click</b><br/>
      Aim at a tree (center dot), get close, and chop.
    </div>
    <div id="chopWrap">
      <div id="barOuter"><div id="barInner"></div></div>
      <div id="targetLine">Target: <span id="targetName">None</span></div>
    </div>
  </div>
  <div id="centerDot"></div>

  <!-- Touch UI (shown automatically on mobile / touch devices) -->
  <div id="touchUI" class="touch-ui">
    <div id="joyBase" class="touch-joystick" aria-label="Move joystick">
      <div id="joyStick" class="stick"></div>
    </div>

  <!-- Donation Modal (blocks input; game continues rendering behind) -->
  <div id="donationModal" class="modalOverlay" role="dialog" aria-modal="true" aria-labelledby="modalTitle">
    <div class="modalCard">
      <div class="modalTitle" id="modalTitle">Welcome to Tree Chop! How much do you donate?</div>

      <div class="modalRow">
        <button id="donatePlusBtn" class="modalBtn modalBtnPlus" aria-label="Increase donation">+</button>
        <div id="donateValue" class="modalValue">$0</div>

        <div class="modalSpacer"></div>

        <button id="playBtn" class="modalBtn modalBtnPlay" disabled>Play</button>
      </div>

    </div>
  </div>

    <div id="chopBtn" class="touch-chop" aria-label="Chop button">CHOP</div>

    <div class="touch-tip" id="touchTip">Left thumb: move • Right thumb drag: look • Hold CHOP: chop</div>
  </div>


  <script type="module">
    import * as THREE from "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js";

    // ---------- Basic setup ----------
    const scene = new THREE.Scene();

    // Blue sky background
    scene.background = new THREE.Color(0x78b7ff);

    // Softer fog (optional, keep it light so it doesn’t darken the scene)
    scene.fog = new THREE.Fog(0x78b7ff, 140, 520);

    const camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 500);
    camera.position.set(0, 6, 10);

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
    document.body.appendChild(renderer.domElement);
    renderer.domElement.tabIndex = 0;           // make canvas focusable
    renderer.domElement.style.outline = "none"; // no focus ring
    renderer.domElement.focus();
    // Prevent browser touch gestures from interfering with gameplay
    renderer.domElement.style.touchAction = "none";

        // Extra iOS Safari guards: prevent pinch/double-tap zoom
    document.addEventListener("gesturestart", (e) => e.preventDefault(), { passive:false });
    document.addEventListener("gesturechange", (e) => e.preventDefault(), { passive:false });
    document.addEventListener("gestureend", (e) => e.preventDefault(), { passive:false });

    // Prevent double-tap to zoom (best-effort)
    let lastTouchEnd = 0;
    document.addEventListener("touchend", (e) => {
      const now = Date.now();
      if (now - lastTouchEnd <= 300) e.preventDefault();
      lastTouchEnd = now;
    }, { passive:false });


    // ---------- Lights ----------
    // Sky + ground bounce lighting (very outdoor-looking)
    const hemi = new THREE.HemisphereLight(0xbfdcff, 0x2a4a2a, 0.95);
    scene.add(hemi);

    // Sun light
    const sun = new THREE.DirectionalLight(0xffffff, 1.25);
    sun.position.set(80, 140, 60);
    sun.castShadow = false; // keep simple for now
    scene.add(sun);

    // Visible sun disc in the sky (simple)
    const sunDisc = new THREE.Mesh(
      new THREE.SphereGeometry(6, 24, 16),
      new THREE.MeshBasicMaterial({ color: 0xfff2b0 })
    );
    sunDisc.position.copy(sun.position);
    scene.add(sunDisc);


    // ---------- Ground (rolling hills) ----------
    const groundSize = 520;
    const groundSegs = 220;

    // More segments = smoother hills
    const groundGeo = new THREE.PlaneGeometry(groundSize, groundSize, groundSegs, groundSegs);
    groundGeo.rotateX(-Math.PI / 2);

    // Lightweight 2D value-noise (no external libs)
    function hash2(x, z) {
      // deterministic pseudo-random 0..1
      const s = Math.sin(x * 127.1 + z * 311.7) * 43758.5453123;
      return s - Math.floor(s);
    }
    function smoothstep(t) { return t * t * (3 - 2 * t); }
    function lerp(a, b, t) { return a + (b - a) * t; }

    function valueNoise2D(x, z) {
      const x0 = Math.floor(x), z0 = Math.floor(z);
      const x1 = x0 + 1,       z1 = z0 + 1;

      const sx = smoothstep(x - x0);
      const sz = smoothstep(z - z0);

      const n00 = hash2(x0, z0);
      const n10 = hash2(x1, z0);
      const n01 = hash2(x0, z1);
      const n11 = hash2(x1, z1);

      const ix0 = lerp(n00, n10, sx);
      const ix1 = lerp(n01, n11, sx);
      return lerp(ix0, ix1, sz);
    }

    // Fractal noise (octaves) for nicer hills
    function fbm(x, z) {
      let amp = 1.0;
      let freq = 0.035;
      let sum = 0.0;
      let norm = 0.0;

      for (let i = 0; i < 5; i++) {
        sum += (valueNoise2D(x * freq, z * freq) * 2 - 1) * amp;
        norm += amp;
        amp *= 0.5;
        freq *= 2.0;
      }
      return sum / norm; // ~ -1..1
    }

    const HILL_HEIGHT = 7.0;

    function getGroundHeight(x, z) {
      return fbm(x, z) * HILL_HEIGHT;
    }

    // Approximate ground normal using finite differences
    function getGroundNormal(x, z) {
      const eps = 0.75;
      const hL = getGroundHeight(x - eps, z);
      const hR = getGroundHeight(x + eps, z);
      const hD = getGroundHeight(x, z - eps);
      const hU = getGroundHeight(x, z + eps);

      const n = new THREE.Vector3(hL - hR, 2 * eps, hD - hU);
      return n.normalize();
    }


    // Displace vertices in Y
    const pos = groundGeo.attributes.position;
    for (let i = 0; i < pos.count; i++) {
      const x = pos.getX(i);
      const z = pos.getZ(i);

      // Rolling hills: broad + gentle
      const h = fbm(x, z);
      const height = h * HILL_HEIGHT;

      pos.setY(i, height);
    }
    pos.needsUpdate = true;
    groundGeo.computeVertexNormals();

    // Grass material
    const groundMat = new THREE.MeshStandardMaterial({
      color: 0x2f8f3f,      // grass green
      roughness: 1.0,
      metalness: 0.0
    });

    const ground = new THREE.Mesh(groundGeo, groundMat);
    ground.position.y = 0;
    scene.add(ground);

    // Rocks (sit on hills + align to slope)
    const rockMat = new THREE.MeshStandardMaterial({ color: 0x2b2f33, roughness: 1 });
    for (let i = 0; i < 30; i++) {
      const size = 0.4 + Math.random() * 0.8;
      const g = new THREE.DodecahedronGeometry(size);
      g.computeBoundingSphere();
      const r = g.boundingSphere ? g.boundingSphere.radius : size;

      const m = new THREE.Mesh(g, rockMat);

      const x = (Math.random() - 0.5) * 120;
      const z = (Math.random() - 0.5) * 120;

      const y = getGroundHeight(x, z);
      const n = getGroundNormal(x, z);

      // Place rock so it rests on surface (center lifted by radius)
      m.position.set(x, y + r * 0.9, z);

      // Align "up" to slope normal, then random twist around that normal
      m.quaternion.setFromUnitVectors(new THREE.Vector3(0, 1, 0), n);
      m.quaternion.premultiply(new THREE.Quaternion().setFromAxisAngle(n, Math.random() * Math.PI * 2));

      scene.add(m);
    }

    // ---------- Player ----------
    const player = new THREE.Group();
    scene.add(player);

    const bodyGeo = new THREE.CapsuleGeometry(0.45, 0.8, 6, 10);
    const bodyMat = new THREE.MeshStandardMaterial({ color: 0x7aa7ff, roughness: 0.7 });
    const body = new THREE.Mesh(bodyGeo, bodyMat);
    body.position.y = 0.9;
    player.add(body);

    const axeGeo = new THREE.BoxGeometry(0.1, 0.6, 0.1);
    const axeMat = new THREE.MeshStandardMaterial({ color: 0xd9d9d9, roughness: 0.4 });
    const axe = new THREE.Mesh(axeGeo, axeMat);
    axe.position.set(0.55, 1.1, 0.2);
    player.add(axe);

    player.position.set(0, 0, 0);

    // ---------- UI ----------
    const scoreEl = document.getElementById("score");
    const woodEl = document.getElementById("wood");
    const barInner = document.getElementById("barInner");
    const targetNameEl = document.getElementById("targetName");
    const hud = document.getElementById("hud");
    // ---------- Donation Modal ----------
    const donationModal = document.getElementById("donationModal");
    const donatePlusBtn = document.getElementById("donatePlusBtn");
    const donateValueEl = document.getElementById("donateValue");
    const playBtn = document.getElementById("playBtn");

    const donationValues = [0, 1, 10, 69];
    let donationIndex = 0;        // starts at $0
    let donateTappedOnce = false; // Play only works after + tapped at least once
    let modalOpen = true;

    function updateDonationUI(){
      donateValueEl.textContent = `$${donationValues[donationIndex]}`;
      playBtn.disabled = !donateTappedOnce;

      // When at max ($69), + becomes inert (still clickable but does nothing)
      if (donationIndex >= donationValues.length - 1) {
        donatePlusBtn.style.opacity = "0.75";
      } else {
        donatePlusBtn.style.opacity = "1";
      }
    }

    function closeDonationModal(){
      modalOpen = false;
      donationModal.classList.add("modalHidden");

      // Return focus to the canvas so keyboard works immediately
      renderer.domElement.focus();
    }

    // Keep clicks/touches from "falling through" to the canvas
    donationModal.addEventListener("pointerdown", (e) => {
      e.preventDefault();
      e.stopPropagation();
    }, { passive:false });

    donatePlusBtn.addEventListener("click", (e) => {
      e.preventDefault();
      e.stopPropagation();
      initAudio();

      donateTappedOnce = true;
      if (donationIndex < donationValues.length - 1) {
        donationIndex++;
      }
      updateDonationUI();
    });

    playBtn.addEventListener("click", (e) => {
      e.preventDefault();
      e.stopPropagation();
      initAudio();

      if (!donateTappedOnce) return; // hard guard
      closeDonationModal();
    });

    updateDonationUI();




    let score = 0;
    let wood = 0;

    // ---------- Input ----------
    const keys = new Set();

    document.addEventListener("keydown", (e) => {
      // Keep focus / pointer lock stable and stop browser shortcuts
      if (["KeyW","KeyA","KeyS","KeyD","ShiftLeft","ShiftRight","Space",
          "ArrowUp","ArrowDown","ArrowLeft","ArrowRight"].includes(e.code)) {
        e.preventDefault();
      }
      keys.add(e.code);
    }, { passive: false });

    document.addEventListener("keyup", (e) => {
      keys.delete(e.code);
    });

    // Avoid "stuck keys" if the tab loses focus
    window.addEventListener("blur", () => keys.clear());

    let isChopping = false;
    window.addEventListener("mousedown", (e) => { if (e.button === 0) isChopping = true; });
    window.addEventListener("mouseup", (e) => { if (e.button === 0) isChopping = false; });

    // ---------- Touch controls ----------
    const touchUI = document.getElementById("touchUI");
    const joyBase = document.getElementById("joyBase");
    const joyStick = document.getElementById("joyStick");
    const chopBtn = document.getElementById("chopBtn");
    const touchTip = document.getElementById("touchTip");

    const isTouchDevice =
      ("ontouchstart" in window) ||
      (navigator.maxTouchPoints && navigator.maxTouchPoints > 0) ||
      window.matchMedia?.("(pointer: coarse)")?.matches;

    // joystick vector: x = right(+), y = forward(+)
    const joy = { active:false, pid:null, cx:0, cy:0, x:0, y:0, sprint:false };
    const joyRadius = 52; // px (stick travel)

    // touch-look
    const look = { active:false, pid:null, lastX:0, lastY:0 };

    if (isTouchDevice) {
      touchUI.classList.add("show");

      // Update hint for mobile (optional: hide desktop hint text)
      const hint = document.getElementById("hint");
      if (hint) hint.innerHTML = `Touch: <b>Left joystick</b> move • <b>Right drag</b> look • <b>Hold CHOP</b>`;

      // Prevent page scrolling while interacting
      document.body.style.overscrollBehavior = "none";
      document.body.style.touchAction = "none";
    } else {
      // Hide the mobile tip on desktop
      if (touchTip) touchTip.style.display = "none";
    }

    function setJoyFromPointer(px, py) {
      const dx = px - joy.cx;
      const dy = py - joy.cy;

      // clamp to radius
      const len = Math.hypot(dx, dy) || 1;
      const clampedLen = Math.min(len, joyRadius);
      const nx = (dx / len) * clampedLen;
      const ny = (dy / len) * clampedLen;

      // stick position
      joyStick.style.transform = `translate(${nx - 32}px, ${ny - 32}px)`; // 64px stick => -32 offset

      // normalized movement vector
      joy.x = nx / joyRadius;
      joy.y = -ny / joyRadius; // invert so up is forward

      // simple sprint when pushed far
      joy.sprint = (Math.hypot(joy.x, joy.y) > 0.88);
    }

    function resetJoy() {
      joy.active = false;
      joy.pid = null;
      joy.x = 0; joy.y = 0; joy.sprint = false;
      joyStick.style.transform = "translate(-32px, -32px)";
    }

    // Joystick pointer events
    joyBase?.addEventListener("pointerdown", (e) => {
      if (!isTouchDevice) return;
      e.preventDefault();

      initAudio(); // unlock audio on gesture
      joyBase.setPointerCapture(e.pointerId);

      const rect = joyBase.getBoundingClientRect();
      joy.active = true;
      joy.pid = e.pointerId;
      joy.cx = rect.left + rect.width * 0.5;
      joy.cy = rect.top + rect.height * 0.5;

      setJoyFromPointer(e.clientX, e.clientY);
    }, { passive:false });

    joyBase?.addEventListener("pointermove", (e) => {
      if (!joy.active || e.pointerId !== joy.pid) return;
      e.preventDefault();
      setJoyFromPointer(e.clientX, e.clientY);
    }, { passive:false });

    joyBase?.addEventListener("pointerup", (e) => {
      if (!joy.active || e.pointerId !== joy.pid) return;
      e.preventDefault();
      resetJoy();
    }, { passive:false });

    joyBase?.addEventListener("pointercancel", () => resetJoy());

    // Chop button (hold)
    function setChop(on) { isChopping = on; }
    chopBtn?.addEventListener("pointerdown", (e) => {
      if (!isTouchDevice) return;
      e.preventDefault();
      initAudio();
      chopBtn.setPointerCapture(e.pointerId);
      setChop(true);
    }, { passive:false });

    chopBtn?.addEventListener("pointerup", (e) => {
      if (!isTouchDevice) return;
      e.preventDefault();
      setChop(false);
    }, { passive:false });

    chopBtn?.addEventListener("pointercancel", () => setChop(false));

    // Touch-look: any drag on canvas NOT starting on UI controls
    function isOnTouchUI(target) {
      return target === joyBase || target === joyStick || target === chopBtn || joyBase?.contains(target) || chopBtn?.contains(target);
    }

    renderer.domElement.addEventListener("pointerdown", (e) => {
      if (!isTouchDevice) return;
      if (isOnTouchUI(e.target)) return;

      e.preventDefault();
      initAudio();

      look.active = true;
      look.pid = e.pointerId;
      look.lastX = e.clientX;
      look.lastY = e.clientY;

      renderer.domElement.setPointerCapture(e.pointerId);
    }, { passive:false });

    renderer.domElement.addEventListener("pointermove", (e) => {
      if (!isTouchDevice) return;
      if (!look.active || e.pointerId !== look.pid) return;

      e.preventDefault();
      const dx = e.clientX - look.lastX;
      const dy = e.clientY - look.lastY;
      look.lastX = e.clientX;
      look.lastY = e.clientY;

      // Similar feel to mouse sensitivity, tuned for touch
      const touchLookSensitivity = mouseSensitivity * 2.4;
      camYaw   -= dx * touchLookSensitivity;
      camPitch += dy * touchLookSensitivity;
      camPitch = Math.max(pitchMin, Math.min(pitchMax, camPitch));
    }, { passive:false });

    function endLook(e) {
      if (!look.active) return;
      if (e && e.pointerId !== look.pid) return;
      look.active = false;
      look.pid = null;
    }

    renderer.domElement.addEventListener("pointerup", endLook, { passive:false });
    renderer.domElement.addEventListener("pointercancel", endLook, { passive:false });


    // ---------- Audio (procedural WebAudio) ----------
    let audioCtx = null;
    let masterGain = null;

    function initAudio() {
      if (audioCtx) return;
      audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      masterGain = audioCtx.createGain();
      masterGain.gain.value = 0.25;
      masterGain.connect(audioCtx.destination);
    }

    function playChopSound() {
      if (!audioCtx) return;

      const t = audioCtx.currentTime;

      // Short "thunk": oscillator + quick envelope
      const osc = audioCtx.createOscillator();
      osc.type = "triangle";
      osc.frequency.setValueAtTime(180 + Math.random() * 60, t);
      osc.frequency.exponentialRampToValueAtTime(90 + Math.random() * 30, t + 0.06);

      const gain = audioCtx.createGain();
      gain.gain.setValueAtTime(0.0001, t);
      gain.gain.exponentialRampToValueAtTime(0.25 + Math.random() * 0.12, t + 0.01);
      gain.gain.exponentialRampToValueAtTime(0.0001, t + 0.09);

      // Add a little noise "crunch" for wood fibers
      const noise = audioCtx.createBufferSource();
      const buffer = audioCtx.createBuffer(1, audioCtx.sampleRate * 0.12, audioCtx.sampleRate);
      const data = buffer.getChannelData(0);
      for (let i = 0; i < data.length; i++) data[i] = (Math.random() * 2 - 1) * 0.6;
      noise.buffer = buffer;

      const noiseFilter = audioCtx.createBiquadFilter();
      noiseFilter.type = "bandpass";
      noiseFilter.frequency.setValueAtTime(900 + Math.random() * 400, t);
      noiseFilter.Q.setValueAtTime(1.5, t);

      const noiseGain = audioCtx.createGain();
      noiseGain.gain.setValueAtTime(0.0001, t);
      noiseGain.gain.exponentialRampToValueAtTime(0.10 + Math.random() * 0.06, t + 0.01);
      noiseGain.gain.exponentialRampToValueAtTime(0.0001, t + 0.08);

      osc.connect(gain);
      gain.connect(masterGain);

      noise.connect(noiseFilter);
      noiseFilter.connect(noiseGain);
      noiseGain.connect(masterGain);

      osc.start(t);
      osc.stop(t + 0.12);

      noise.start(t);
      noise.stop(t + 0.12);
    }

    function playTreeThud() {
      if (!audioCtx) return;
      const t = audioCtx.currentTime;

      const osc = audioCtx.createOscillator();
      osc.type = "sine";
      osc.frequency.setValueAtTime(80, t);
      osc.frequency.exponentialRampToValueAtTime(45, t + 0.18);

      const gain = audioCtx.createGain();
      gain.gain.setValueAtTime(0.0001, t);
      gain.gain.exponentialRampToValueAtTime(0.35, t + 0.01);
      gain.gain.exponentialRampToValueAtTime(0.0001, t + 0.25);

      osc.connect(gain);
      gain.connect(masterGain);

      osc.start(t);
      osc.stop(t + 0.28);
    }



    // ---------- Helpers ----------
    const clock = new THREE.Clock();
    const raycaster = new THREE.Raycaster();
    const tmpV = new THREE.Vector3();
    const tmpV2 = new THREE.Vector3();
    const UP = new THREE.Vector3(0, 1, 0);

    function clamp01(x){ return Math.max(0, Math.min(1, x)); }
    function easeOutCubic(t){ return 1 - Math.pow(1 - t, 3); }

    // three r160-safe angle lerp (shortest path)
    function lerpAngle(a, b, t) {
      const TWO_PI = Math.PI * 2;
      let delta = (b - a) % TWO_PI;
      if (delta > Math.PI) delta -= TWO_PI;
      if (delta < -Math.PI) delta += TWO_PI;
      return a + delta * t;
    }

    // ---------- Particles (woodchips + leaves) ----------
    const particles = []; // { mesh, v, life, maxLife, spin, drag, gravity, groundBounce, type }

    const woodChipMat = new THREE.MeshStandardMaterial({ color: 0x9a6b3a, roughness: 1 });
    const leafMat     = new THREE.MeshStandardMaterial({ color: 0x2f7d46, roughness: 1, side: THREE.DoubleSide });

    const woodChipGeo = new THREE.BoxGeometry(0.06, 0.02, 0.02);
    const leafGeo     = new THREE.PlaneGeometry(0.08, 0.10);

    // ---------- "White puddle" splat ----------
    const puddleMat = new THREE.MeshBasicMaterial({
      color: 0xffffff,
      transparent: true,
      opacity: 0.95,
      depthWrite: false
    });
    const puddleGeo = new THREE.CircleGeometry(1, 40);

    function spawnWhitePuddleExplosion(tree) {
      // Base position near the tree trunk on the ground
      const baseX = tree.position.x;
      const baseZ = tree.position.z;

      // Main puddle
      {
        const m = new THREE.Mesh(puddleGeo, puddleMat.clone());
        const y = getGroundHeight(baseX, baseZ) + 0.015;
        m.position.set(baseX, y, baseZ);
        m.rotation.x = -Math.PI / 2;

        // Start small, expand fast
        const endScale = 1.2 + Math.random() * 1.6; // overall radius feel
        m.scale.set(0.08, 0.08, 0.08);

        scene.add(m);
        particles.push({
          mesh: m,
          v: new THREE.Vector3(0, 0, 0),
          life: 1.1,
          maxLife: 1.1,
          spin: new THREE.Vector3(0, 0, 0),
          drag: 1,
          gravity: 0,
          groundBounce: 0,
          type: "puddle",
          startScale: 0.08,
          endScale
        });
      }

      // Droplets (small splats around it)
      const drops = 5 + Math.floor(Math.random() * 5); // 5..9
      for (let i = 0; i < drops; i++) {
        const m = new THREE.Mesh(puddleGeo, puddleMat.clone());
        m.material.opacity = 0.85;

        const r = 0.6 + Math.random() * 1.8;
        const a = Math.random() * Math.PI * 2;
        const x = baseX + Math.cos(a) * r;
        const z = baseZ + Math.sin(a) * r;
        const y = getGroundHeight(x, z) + 0.015;

        m.position.set(x, y, z);
        m.rotation.x = -Math.PI / 2;

        const endScale = 0.25 + Math.random() * 0.55;
        m.scale.set(0.05, 0.05, 0.05);

        scene.add(m);
        particles.push({
          mesh: m,
          v: new THREE.Vector3(0, 0, 0),
          life: 0.75 + Math.random() * 0.55,
          maxLife: 0.75 + Math.random() * 0.55,
          spin: new THREE.Vector3(0, 0, 0),
          drag: 1,
          gravity: 0,
          groundBounce: 0,
          type: "puddle",
          startScale: 0.05,
          endScale
        });
      }
    }

    function spawnChopParticles(tree) {
      // spawn at about chest height near trunk
      const origin = tree.position.clone();
      origin.y = tree.position.y + 1.2;

      // determine a direction from player -> tree (chips fly away from trunk face)
      tmpV.copy(tree.position).sub(player.position);
      tmpV.y = 0;
      if (tmpV.lengthSq() < 0.0001) tmpV.set(0, 0, 1);
      tmpV.normalize();

      // --- woodchips (fast) ---
      const chipCount = 10 + Math.floor(Math.random() * 8);
      for (let i = 0; i < chipCount; i++) {
        const m = new THREE.Mesh(woodChipGeo, woodChipMat);
        m.position.copy(origin);
        m.position.x += (Math.random() - 0.5) * 0.18;
        m.position.y += (Math.random() - 0.5) * 0.20;
        m.position.z += (Math.random() - 0.5) * 0.18;

        // velocity: mostly outward + up
        const v = new THREE.Vector3(
          tmpV.x * (2.0 + Math.random() * 2.5) + (Math.random() - 0.5) * 1.5,
          2.0 + Math.random() * 2.5,
          tmpV.z * (2.0 + Math.random() * 2.5) + (Math.random() - 0.5) * 1.5
        );

        m.rotation.set(Math.random() * Math.PI, Math.random() * Math.PI, Math.random() * Math.PI);

        scene.add(m);
        particles.push({
          mesh: m,
          v,
          life: 0.45 + Math.random() * 0.25,
          maxLife: 0.7,
          spin: new THREE.Vector3((Math.random()-0.5)*14, (Math.random()-0.5)*14, (Math.random()-0.5)*14),
          drag: 0.88,
          gravity: -12.0,
          groundBounce: 0.25,
          type: "chip"
        });
      }

      // --- leaves (slow + floaty) ---
      const leafCount = 6 + Math.floor(Math.random() * 6);
      for (let i = 0; i < leafCount; i++) {
        const m = new THREE.Mesh(leafGeo, leafMat);
        m.position.copy(origin);
        m.position.y += 1.3 + Math.random() * 0.8; // originate higher
        m.position.x += (Math.random() - 0.5) * 0.9;
        m.position.z += (Math.random() - 0.5) * 0.9;

        // leaves drift down
        const v = new THREE.Vector3(
          (Math.random() - 0.5) * 0.8 + tmpV.x * 0.3,
          -0.2 - Math.random() * 0.6,
          (Math.random() - 0.5) * 0.8 + tmpV.z * 0.3
        );

        m.rotation.set(0, Math.random() * Math.PI * 2, Math.random() * Math.PI * 2);

        scene.add(m);
        particles.push({
          mesh: m,
          v,
          life: 1.6 + Math.random() * 1.1,
          maxLife: 2.8,
          spin: new THREE.Vector3((Math.random()-0.5)*3, (Math.random()-0.5)*2, (Math.random()-0.5)*6),
          drag: 0.985,
          gravity: -1.0,
          groundBounce: 0.0,
          type: "leaf"
        });
      }
    }

    function updateParticles(dt) {
      for (let i = particles.length - 1; i >= 0; i--) {
        const p = particles[i];

        // integrate
        p.v.y += p.gravity * dt;
        p.v.multiplyScalar(Math.pow(p.drag, dt * 60));

        p.mesh.position.addScaledVector(p.v, dt);

        // spin
        p.mesh.rotation.x += p.spin.x * dt;
        p.mesh.rotation.y += p.spin.y * dt;
        p.mesh.rotation.z += p.spin.z * dt;

        // ground
        const gy = getGroundHeight(p.mesh.position.x, p.mesh.position.z) + 0.02;
        if (p.mesh.position.y < gy) {
          p.mesh.position.y = gy;
          if (p.groundBounce > 0) {
            p.v.y = Math.abs(p.v.y) * p.groundBounce;
            p.v.x *= 0.75;
            p.v.z *= 0.75;
          } else {
            // leaves just rest
            p.v.set(0, 0, 0);
          }
        }

        // life/fade
        p.life -= dt;
        const alpha = Math.max(0, Math.min(1, p.life / p.maxLife));

        // Special behavior: puddles expand quickly then fade
        if (p.type === "puddle") {
          const t = 1 - (p.life / p.maxLife);                 // 0..1
          const grow = easeOutCubic(Math.min(1, t * 3.0));     // fast expansion
          const s = p.startScale + (p.endScale - p.startScale) * grow;

          p.mesh.scale.set(s, s, s);
          p.mesh.rotation.x = -Math.PI / 2;

          // keep pinned to ground
          const py = getGroundHeight(p.mesh.position.x, p.mesh.position.z) + 0.015;
          p.mesh.position.y = py;
        }

        // quick fade on chips (material transparency)
        if (p.type === "chip") {
          p.mesh.material.transparent = true;
          p.mesh.material.opacity = alpha;
        } else {
          p.mesh.material.transparent = true;
          p.mesh.material.opacity = alpha;
        }

        if (p.life <= 0) {
          scene.remove(p.mesh);
          particles.splice(i, 1);
        }
      }
    }



    // ---------- Trees ----------
    const trees = [];
    const treeGroup = new THREE.Group();
    scene.add(treeGroup);

    // For raycast, we keep a list of mesh objects that belong to trees
    const treePickMeshes = [];

    function makeTree(name) {
      const g = new THREE.Group();
      g.name = name;
      g.userData.isTree = true;

      // trunk (bottom sits on y=0 because trunk height=2 and centered at y=1)
      const trunk = new THREE.Mesh(
        new THREE.CylinderGeometry(0.25, 0.35, 2.0, 8),
        new THREE.MeshStandardMaterial({ color: 0x6b4a2b, roughness: 1 })
      );
      trunk.position.y = 1.0;
      trunk.userData.treeRoot = g;
      g.add(trunk);

      // leaves
      const leaves = new THREE.Mesh(
        new THREE.ConeGeometry(1.2, 2.8, 10),
        new THREE.MeshStandardMaterial({ color: 0x2f7d46, roughness: 1 })
      );
      leaves.position.y = 3.0;
      leaves.userData.treeRoot = g;
      g.add(leaves);

      // Raycast candidates
      treePickMeshes.push(trunk, leaves);

      // chop + fall state
      g.userData.hp = 1.0;          // 0..1
      g.userData.maxHp = 1.0;
      g.userData.alive = true;

      g.userData.falling = false;
      g.userData.fallT = 0;         // 0..1 over fall duration
      g.userData.fallAxis = new THREE.Vector3(1,0,0);
      g.userData.fallAngle = 0;
      g.userData.removeAt = null;   // time in seconds (clock) to remove after hitting ground

      return g;
    }

    function scatterTrees(count = 70) {
      for (let i = 0; i < count; i++) {
        const t = makeTree("Tree " + (i + 1));
        const x = (Math.random() - 0.5) * 140;
        const z = (Math.random() - 0.5) * 140;

        if (Math.hypot(x, z) < 10) { i--; continue; }

        // Sit tree base on terrain
        const y = getGroundHeight(x, z);
        const n = getGroundNormal(x, z);

        t.position.set(x, y, z);

        // Align tree "up" to slope normal
        t.quaternion.setFromUnitVectors(new THREE.Vector3(0, 1, 0), n);

        // Random twist around the slope normal (so forests don’t look uniform)
        t.quaternion.premultiply(new THREE.Quaternion().setFromAxisAngle(n, Math.random() * Math.PI * 2));

        const s = 0.8 + Math.random() * 0.6;
        t.scale.set(s, s, s);

        treeGroup.add(t);
        trees.push(t);
      }
    }
    scatterTrees(70);

    // ---------- Wood drops ----------
    const woodDrops = [];
    const woodGroup = new THREE.Group();
    scene.add(woodGroup);

    function spawnWoodDrops(tree, fallDir) {
      const dropCount = 2 + Math.floor(Math.random() * 3); // 2..4
      const logMat = new THREE.MeshStandardMaterial({ color: 0x8a5a34, roughness: 1 });

      for (let i = 0; i < dropCount; i++) {
        const log = new THREE.Mesh(
          new THREE.CylinderGeometry(0.12, 0.12, 0.45, 8),
          logMat
        );
        log.rotation.z = Math.PI * 0.5;
        log.position.copy(tree.position);
        log.position.y = tree.position.y + 0.25;
        log.position.addScaledVector(fallDir, 0.6 + Math.random() * 0.8);
        log.position.x += (Math.random() - 0.5) * 0.4;
        log.position.z += (Math.random() - 0.5) * 0.4;

        // simple velocity + gravity
        const v = new THREE.Vector3(
          (Math.random() - 0.5) * 1.2 + fallDir.x * (0.5 + Math.random()),
          2.2 + Math.random() * 1.2,
          (Math.random() - 0.5) * 1.2 + fallDir.z * (0.5 + Math.random())
        );

        log.userData.v = v;
        log.userData.collected = false;

        woodGroup.add(log);
        woodDrops.push(log);
      }
    }

    function updateWoodDrops(dt) {
      const gravity = -8.5;

      for (let i = woodDrops.length - 1; i >= 0; i--) {
        const d = woodDrops[i];
        if (d.userData.collected) continue;

        // physics-lite
        d.userData.v.y += gravity * dt;
        d.position.addScaledVector(d.userData.v, dt);

        // ground collide
        const gy = getGroundHeight(d.position.x, d.position.z) + 0.18;
        if (d.position.y < gy) {
          d.position.y = gy;
          d.userData.v.y *= -0.25; // small bounce
          d.userData.v.x *= 0.82;
          d.userData.v.z *= 0.82;

          // stop jitter
          if (Math.abs(d.userData.v.y) < 0.2) d.userData.v.y = 0;
        }

        // spin a bit
        d.rotation.x += dt * 1.8;
        d.rotation.y += dt * 1.1;

        // auto-collect if close to player
        tmpV.copy(d.position).sub(player.position);
        tmpV.y = 0;
        if (tmpV.length() < 1.15) {
          d.userData.collected = true;
          woodGroup.remove(d);
          woodDrops.splice(i, 1);

          wood += 1;
          woodEl.textContent = String(wood);
        }
      }
    }

    // ---------- Targeting (center-screen raycast) ----------
    function pickTreeFromCenter() {
      raycaster.setFromCamera({ x: 0, y: 0 }, camera);
      const hits = raycaster.intersectObjects(treePickMeshes, false);

      if (!hits.length) return null;

      // find first alive tree within range
      const maxDist = 5.0;

      for (const h of hits) {
        const root = h.object.userData.treeRoot;
        if (!root) continue;
        if (!root.userData.alive) continue;
        if (root.userData.falling) continue;

        // distance check from player to tree base
        tmpV.copy(root.position).sub(player.position);
        tmpV.y = 0;
        if (tmpV.length() <= maxDist) return root;
      }

      return null;
    }

    // ---------- Chopping + falling ----------
    const chopRate = 0.60; // hp per second
    const fallDuration = 0.65; // seconds
    const removeDelayAfterFall = 1.1;
    // Chop "hit" cadence (visual + sound)
    let chopHitTimer = 0;
    const chopHitInterval = 0.12; // seconds between bursts while holding
    let lastWobbleTree = null;



    function startTreeFall(tree) {
      tree.userData.falling = true;
      tree.userData.fallT = 0;
      tree.userData.fallAngle = 0;

      // Fall direction AWAY from player (tree -> away direction)
      tmpV.copy(tree.position).sub(player.position);
      tmpV.y = 0;
      if (tmpV.lengthSq() < 0.0001) tmpV.set(1, 0, 0);
      tmpV.normalize(); // this points from player to tree, so "away from player" for the tree top

      // Axis to rotate around so the tree tips in tmpV direction:
      // rotate around axis perpendicular to UP and fallDir.
      tmpV2.crossVectors(UP, tmpV).normalize();
      if (tmpV2.lengthSq() < 0.0001) tmpV2.set(0, 0, 1);

      tree.userData.fallAxis.copy(tmpV2);

      // Spawn wood after impact (we’ll do it when fall completes)
      tree.userData.fallDir = tmpV.clone();
    }

    function updateFallingTrees(dt, nowSeconds) {
      for (let i = trees.length - 1; i >= 0; i--) {
        const t = trees[i];
        if (!t.userData.alive) continue;

        if (t.userData.falling) {
          t.userData.fallT = Math.min(1, t.userData.fallT + dt / fallDuration);
          const eased = easeOutCubic(t.userData.fallT);

          const targetAngle = Math.PI / 2; // 90 degrees
          const angle = eased * targetAngle;
          t.userData.fallAngle = angle;

          // Apply axis-angle rotation (keep base at y=0)
          t.setRotationFromAxisAngle(t.userData.fallAxis, angle);

          // when impact happens (fallT hits 1), schedule removal + spawn wood once
          if (t.userData.fallT >= 1 && t.userData.removeAt == null) {
            t.userData.removeAt = nowSeconds + removeDelayAfterFall;

            // drop wood in the direction it fell
            playTreeThud();
            spawnWoodDrops(t, t.userData.fallDir || new THREE.Vector3(1,0,0));

            // 1/10 chance: impact "white puddle" splat
            if (Math.random() < 0.25) {
              spawnWhitePuddleExplosion(t);
            }
          }

          // remove after delay
          if (t.userData.removeAt != null && nowSeconds >= t.userData.removeAt) {
            t.userData.alive = false;
            treeGroup.remove(t);
          }
        }
      }
    }

    // ---------- Movement tuning ----------
    const baseSpeed = 6.0;
    const sprintSpeed = 10.0;
    const turnSpeed = 12.0;

    // ---------- Jump / gravity ----------
    let playerVy = 0;                // vertical velocity
    let isGrounded = false;
    const jumpSpeed = 6.4;           // jump impulse
    const gravity = -18.0;           // downward accel (units/s^2)


    // --- Mouse-look (pointer lock) ---
    let camYaw = 0;                  // left/right
    let camPitch = -0.35;            // up/down (radians)
    const pitchMin = -1.15;          // can look further down
    const pitchMax = 0.85;           // can look much further up
    const mouseSensitivity = 0.0022;

    // Click to lock pointer (required by browser)
    renderer.domElement.addEventListener("click", () => {
      // Don't pointer-lock if the donation modal is still open
      if (typeof modalOpen !== "undefined" && modalOpen) return;

      renderer.domElement.focus(); // <-- critical for WASD
      initAudio();
      renderer.domElement.requestPointerLock?.();
    });

    // Update yaw/pitch when pointer is locked
    window.addEventListener("mousemove", (e) => {
      if (document.pointerLockElement !== renderer.domElement) return;

      camYaw   -= e.movementX * mouseSensitivity;
      camPitch += e.movementY * mouseSensitivity; // inverted Y
      camPitch = Math.max(pitchMin, Math.min(pitchMax, camPitch));
    });



    // ---------- Game loop ----------
    function animate() {
      requestAnimationFrame(animate);
      
      try {
      const dt = Math.min(clock.getDelta(), 0.05);
      const nowSeconds = clock.elapsedTime;

      // --- Movement (camera-relative) ---
      const sprint = (keys.has("ShiftLeft") || keys.has("ShiftRight")) || (isTouchDevice && joy.sprint);
      const speed = sprint ? sprintSpeed : baseSpeed;

      const move = new THREE.Vector3();

      // Forward/right derived ONLY from mouse-look yaw
      const camForward = new THREE.Vector3(
        -Math.sin(camYaw), 0, -Math.cos(camYaw)
      ).normalize();
        const camRight = new THREE.Vector3()
          .crossVectors(camForward, UP)
          .normalize();

      // Keyboard
      if (keys.has("KeyW")) move.add(camForward);
      if (keys.has("KeyS")) move.sub(camForward);
      if (keys.has("KeyA")) move.sub(camRight);
      if (keys.has("KeyD")) move.add(camRight);

      // Touch joystick
      if (isTouchDevice && (joy.x !== 0 || joy.y !== 0)) {
        move.addScaledVector(camRight, joy.x);
        move.addScaledVector(camForward, joy.y);
      }

      if (move.lengthSq() > 0) {
        move.normalize();

        // Rotate player to face movement direction (camera-relative)
        const targetYaw = Math.atan2(move.x, move.z);
        player.rotation.y = lerpAngle(
          player.rotation.y,
          targetYaw,
          Math.min(1, turnSpeed * dt)
        );


        // Move strictly in camera-facing direction
        player.position.addScaledVector(move, speed * dt);
      }

        // Ground height under player (terrain)
        const groundY = getGroundHeight(player.position.x, player.position.z);

        // Jump (Space) only when grounded
        if (keys.has("Space") && isGrounded) {
          playerVy = jumpSpeed;
          isGrounded = false;
        }

        // Gravity integration
        playerVy += gravity * dt;
        player.position.y += playerVy * dt;

        // Ground collision / landing
        if (player.position.y <= groundY) {
          player.position.y = groundY;
          playerVy = 0;
          isGrounded = true;
        }

      // --- Camera (mouse-look orbit behind player) ---
      const camDistance = 10;
      const camHeight   = 2.2;

      // Build an offset from yaw/pitch like an orbit camera
      const offset = new THREE.Vector3(
        Math.sin(camYaw) * Math.cos(camPitch),
        Math.sin(camPitch),
        Math.cos(camYaw) * Math.cos(camPitch)
      ).multiplyScalar(camDistance);

            // Position camera behind/around player
      const desiredCamPos = player.position.clone().add(offset);
      desiredCamPos.y += camHeight;

      // --- Ground collision (simple clamp) ---
      const minCamY = 0.6;              // keep camera above ground
      desiredCamPos.y = Math.max(minCamY, desiredCamPos.y);

      // Smooth camera
      camera.position.lerp(desiredCamPos, 1 - Math.pow(0.001, dt));

      // Look at player (slightly above center)
      camera.lookAt(player.position.x, player.position.y + 1.2, player.position.z);

      // --- Targeting ---
      const target = pickTreeFromCenter();
      targetNameEl.textContent = target ? target.name : "None";

      // --- Chopping ---
      if (target && isChopping) {
        target.userData.hp = clamp01(target.userData.hp - chopRate * dt);

        // crude feedback: wiggle the axe + shake target slightly
      axe.rotation.z = Math.sin(performance.now() * 0.05) * 0.6;

      // If we switched targets, reset the old tree so it doesn't stay tilted
      if (lastWobbleTree && lastWobbleTree !== target && !lastWobbleTree.userData.falling) {
        lastWobbleTree.rotation.z = 0;
      }
      lastWobbleTree = target;

      // Apply wobble only to non-falling trees
      if (!target.userData.falling) {
        target.rotation.z = Math.sin(performance.now() * 0.03) * 0.06;
      }

        // Trigger particles + sound at a steady "axe hit" rhythm
        chopHitTimer -= dt;
        if (chopHitTimer <= 0) {
          chopHitTimer = chopHitInterval;

          spawnChopParticles(target);
          playChopSound();
        }

        if (target.userData.hp <= 0 && !target.userData.falling) {
          // count as chopped
          score += 1;
          scoreEl.textContent = String(score);

          // begin fall away from player
          startTreeFall(target);

          // reset so next tree hit starts with an immediate burst
          chopHitTimer = 0;
        }
      } else {
        axe.rotation.z = 0;
        chopHitTimer = 0;

        // Clear wobble so trees don't remain tilted after a single chop
        if (lastWobbleTree && !lastWobbleTree.userData.falling) {
          lastWobbleTree.rotation.z = 0;
        }
        lastWobbleTree = null;
      }

      // Update chop bar
      if (target) {
        const pct = (1 - (target.userData.hp / target.userData.maxHp)) * 100;
        barInner.style.width = `${pct.toFixed(1)}%`;
      } else {
        barInner.style.width = `0%`;
      }

      // --- Update falling + drops ---
      updateFallingTrees(dt, nowSeconds);
      updateWoodDrops(dt);
      updateParticles(dt);


      renderer.render(scene, camera);

      } catch (err) {
        console.error(err);
        const hud = document.getElementById("hud");
        if (hud) {
          hud.innerHTML = `
            <div style="font-weight:800;color:#ffb4b4">Runtime error</div>
            <div style="font-size:12px;white-space:pre-wrap">${String(err)}</div>
          `;
        }
      }
    }

    animate();      


    // ---------- Resize ----------
    window.addEventListener("resize", () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
  </script>
</body>
</html>
