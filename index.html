<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Tree Chopping Prototype</title>
  <style>
    html, body { margin:0; padding:0; overflow:hidden; background:#0b0f12; }
    canvas { display:block; }

    /* Minimal HUD */
    #hud {
      position: fixed;
      left: 12px; top: 12px;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      color: #e8f0f7;
      user-select: none;
      background: rgba(0,0,0,0.35);
      padding: 10px 12px;
      border-radius: 12px;
      backdrop-filter: blur(6px);
      max-width: 340px;
    }
    #hint { font-size: 12px; opacity: 0.9; margin-top: 6px; line-height: 1.3; }
    .statline { margin-top: 6px; font-size: 13px; }
    #score, #wood { font-weight: 800; }

    #chopWrap { margin-top: 10px; }
    #barOuter {
      width: 260px; height: 10px;
      border-radius: 999px;
      background: rgba(255,255,255,0.12);
      overflow: hidden;
    }
    #barInner {
      width: 0%;
      height: 100%;
      background: rgba(120, 220, 120, 0.95);
    }
    #targetLine { font-size: 12px; margin-top: 6px; opacity: 0.9; }
    #centerDot {
      position: fixed; left: 50%; top: 50%;
      width: 6px; height: 6px;
      transform: translate(-50%, -50%);
      border-radius: 50%;
      background: rgba(255,255,255,0.7);
      box-shadow: 0 0 0 3px rgba(0,0,0,0.25);
      pointer-events: none;
    }
  </style>
</head>
<body>
  <div id="hud">
    <div class="statline">Score: <span id="score">0</span> &nbsp;•&nbsp; Wood: <span id="wood">0</span></div>
    <div id="hint">
      Move: <b>WASD</b> • Sprint: <b>Shift</b> • Chop: <b>Hold Left Click</b><br/>
      Aim at a tree (center dot), get close, and chop.
    </div>
    <div id="chopWrap">
      <div id="barOuter"><div id="barInner"></div></div>
      <div id="targetLine">Target: <span id="targetName">None</span></div>
    </div>
  </div>
  <div id="centerDot"></div>

  <script type="module">
    import * as THREE from "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js";

    // ---------- Basic setup ----------
    const scene = new THREE.Scene();
    scene.fog = new THREE.Fog(0x0b0f12, 30, 130);

    const camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 500);
    camera.position.set(0, 6, 10);

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
    document.body.appendChild(renderer.domElement);
    renderer.domElement.tabIndex = 0;           // make canvas focusable
    renderer.domElement.style.outline = "none"; // no focus ring
    renderer.domElement.focus();

    // ---------- Lights ----------
    scene.add(new THREE.AmbientLight(0xffffff, 0.35));

    const sun = new THREE.DirectionalLight(0xffffff, 1.0);
    sun.position.set(20, 40, 10);
    scene.add(sun);

    // ---------- Ground ----------
    const groundGeo = new THREE.PlaneGeometry(400, 400, 1, 1);
    const groundMat = new THREE.MeshStandardMaterial({ color: 0x1b2320, roughness: 1, metalness: 0 });
    const ground = new THREE.Mesh(groundGeo, groundMat);
    ground.rotation.x = -Math.PI / 2;
    ground.position.y = 0;
    scene.add(ground);

    // Rocks
    const rockMat = new THREE.MeshStandardMaterial({ color: 0x2b2f33, roughness: 1 });
    for (let i = 0; i < 30; i++) {
      const g = new THREE.DodecahedronGeometry(0.4 + Math.random() * 0.8);
      const m = new THREE.Mesh(g, rockMat);
      m.position.set((Math.random() - 0.5) * 120, 0.4, (Math.random() - 0.5) * 120);
      m.rotation.set(Math.random()*2, Math.random()*2, Math.random()*2);
      scene.add(m);
    }

    // ---------- Player ----------
    const player = new THREE.Group();
    scene.add(player);

    const bodyGeo = new THREE.CapsuleGeometry(0.45, 0.8, 6, 10);
    const bodyMat = new THREE.MeshStandardMaterial({ color: 0x7aa7ff, roughness: 0.7 });
    const body = new THREE.Mesh(bodyGeo, bodyMat);
    body.position.y = 0.9;
    player.add(body);

    const axeGeo = new THREE.BoxGeometry(0.1, 0.6, 0.1);
    const axeMat = new THREE.MeshStandardMaterial({ color: 0xd9d9d9, roughness: 0.4 });
    const axe = new THREE.Mesh(axeGeo, axeMat);
    axe.position.set(0.55, 1.1, 0.2);
    player.add(axe);

    player.position.set(0, 0, 0);

    // ---------- UI ----------
    const scoreEl = document.getElementById("score");
    const woodEl = document.getElementById("wood");
    const barInner = document.getElementById("barInner");
    const targetNameEl = document.getElementById("targetName");

    let score = 0;
    let wood = 0;

    // ---------- Input ----------
    const keys = new Set();

    renderer.domElement.addEventListener("keydown", (e) => {
      keys.add(e.code);
      // prevent arrow keys / space from scrolling if ever used later
      if (["ArrowUp","ArrowDown","ArrowLeft","ArrowRight","Space"].includes(e.code)) e.preventDefault();
    });

    renderer.domElement.addEventListener("keyup", (e) => {
      keys.delete(e.code);
    });

    let isChopping = false;
    window.addEventListener("mousedown", (e) => { if (e.button === 0) isChopping = true; });
    window.addEventListener("mouseup", (e) => { if (e.button === 0) isChopping = false; });

    // ---------- Audio (procedural WebAudio) ----------
    let audioCtx = null;
    let masterGain = null;

    function initAudio() {
      if (audioCtx) return;
      audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      masterGain = audioCtx.createGain();
      masterGain.gain.value = 0.25;
      masterGain.connect(audioCtx.destination);
    }

    function playChopSound() {
      if (!audioCtx) return;

      const t = audioCtx.currentTime;

      // Short "thunk": oscillator + quick envelope
      const osc = audioCtx.createOscillator();
      osc.type = "triangle";
      osc.frequency.setValueAtTime(180 + Math.random() * 60, t);
      osc.frequency.exponentialRampToValueAtTime(90 + Math.random() * 30, t + 0.06);

      const gain = audioCtx.createGain();
      gain.gain.setValueAtTime(0.0001, t);
      gain.gain.exponentialRampToValueAtTime(0.25 + Math.random() * 0.12, t + 0.01);
      gain.gain.exponentialRampToValueAtTime(0.0001, t + 0.09);

      // Add a little noise "crunch" for wood fibers
      const noise = audioCtx.createBufferSource();
      const buffer = audioCtx.createBuffer(1, audioCtx.sampleRate * 0.12, audioCtx.sampleRate);
      const data = buffer.getChannelData(0);
      for (let i = 0; i < data.length; i++) data[i] = (Math.random() * 2 - 1) * 0.6;
      noise.buffer = buffer;

      const noiseFilter = audioCtx.createBiquadFilter();
      noiseFilter.type = "bandpass";
      noiseFilter.frequency.setValueAtTime(900 + Math.random() * 400, t);
      noiseFilter.Q.setValueAtTime(1.5, t);

      const noiseGain = audioCtx.createGain();
      noiseGain.gain.setValueAtTime(0.0001, t);
      noiseGain.gain.exponentialRampToValueAtTime(0.10 + Math.random() * 0.06, t + 0.01);
      noiseGain.gain.exponentialRampToValueAtTime(0.0001, t + 0.08);

      osc.connect(gain);
      gain.connect(masterGain);

      noise.connect(noiseFilter);
      noiseFilter.connect(noiseGain);
      noiseGain.connect(masterGain);

      osc.start(t);
      osc.stop(t + 0.12);

      noise.start(t);
      noise.stop(t + 0.12);
    }

    function playTreeThud() {
      if (!audioCtx) return;
      const t = audioCtx.currentTime;

      const osc = audioCtx.createOscillator();
      osc.type = "sine";
      osc.frequency.setValueAtTime(80, t);
      osc.frequency.exponentialRampToValueAtTime(45, t + 0.18);

      const gain = audioCtx.createGain();
      gain.gain.setValueAtTime(0.0001, t);
      gain.gain.exponentialRampToValueAtTime(0.35, t + 0.01);
      gain.gain.exponentialRampToValueAtTime(0.0001, t + 0.25);

      osc.connect(gain);
      gain.connect(masterGain);

      osc.start(t);
      osc.stop(t + 0.28);
    }



    // ---------- Helpers ----------
    const clock = new THREE.Clock();
    const raycaster = new THREE.Raycaster();
    const tmpV = new THREE.Vector3();
    const tmpV2 = new THREE.Vector3();
    const UP = new THREE.Vector3(0, 1, 0);

    function clamp01(x){ return Math.max(0, Math.min(1, x)); }
    function easeOutCubic(t){ return 1 - Math.pow(1 - t, 3); }

    // ---------- Particles (woodchips + leaves) ----------
    const particles = []; // { mesh, v, life, maxLife, spin, drag, gravity, groundBounce, type }

    const woodChipMat = new THREE.MeshStandardMaterial({ color: 0x9a6b3a, roughness: 1 });
    const leafMat     = new THREE.MeshStandardMaterial({ color: 0x2f7d46, roughness: 1, side: THREE.DoubleSide });

    const woodChipGeo = new THREE.BoxGeometry(0.06, 0.02, 0.02);
    const leafGeo     = new THREE.PlaneGeometry(0.08, 0.10);

    function spawnChopParticles(tree) {
      // spawn at about chest height near trunk
      const origin = tree.position.clone();
      origin.y = 1.2;

      // determine a direction from player -> tree (chips fly away from trunk face)
      tmpV.copy(tree.position).sub(player.position);
      tmpV.y = 0;
      if (tmpV.lengthSq() < 0.0001) tmpV.set(0, 0, 1);
      tmpV.normalize();

      // --- woodchips (fast) ---
      const chipCount = 10 + Math.floor(Math.random() * 8);
      for (let i = 0; i < chipCount; i++) {
        const m = new THREE.Mesh(woodChipGeo, woodChipMat);
        m.position.copy(origin);
        m.position.x += (Math.random() - 0.5) * 0.18;
        m.position.y += (Math.random() - 0.5) * 0.20;
        m.position.z += (Math.random() - 0.5) * 0.18;

        // velocity: mostly outward + up
        const v = new THREE.Vector3(
          tmpV.x * (2.0 + Math.random() * 2.5) + (Math.random() - 0.5) * 1.5,
          2.0 + Math.random() * 2.5,
          tmpV.z * (2.0 + Math.random() * 2.5) + (Math.random() - 0.5) * 1.5
        );

        m.rotation.set(Math.random() * Math.PI, Math.random() * Math.PI, Math.random() * Math.PI);

        scene.add(m);
        particles.push({
          mesh: m,
          v,
          life: 0.45 + Math.random() * 0.25,
          maxLife: 0.7,
          spin: new THREE.Vector3((Math.random()-0.5)*14, (Math.random()-0.5)*14, (Math.random()-0.5)*14),
          drag: 0.88,
          gravity: -12.0,
          groundBounce: 0.25,
          type: "chip"
        });
      }

      // --- leaves (slow + floaty) ---
      const leafCount = 6 + Math.floor(Math.random() * 6);
      for (let i = 0; i < leafCount; i++) {
        const m = new THREE.Mesh(leafGeo, leafMat);
        m.position.copy(origin);
        m.position.y += 1.3 + Math.random() * 0.8; // originate higher
        m.position.x += (Math.random() - 0.5) * 0.9;
        m.position.z += (Math.random() - 0.5) * 0.9;

        // leaves drift down
        const v = new THREE.Vector3(
          (Math.random() - 0.5) * 0.8 + tmpV.x * 0.3,
          -0.2 - Math.random() * 0.6,
          (Math.random() - 0.5) * 0.8 + tmpV.z * 0.3
        );

        m.rotation.set(0, Math.random() * Math.PI * 2, Math.random() * Math.PI * 2);

        scene.add(m);
        particles.push({
          mesh: m,
          v,
          life: 1.6 + Math.random() * 1.1,
          maxLife: 2.8,
          spin: new THREE.Vector3((Math.random()-0.5)*3, (Math.random()-0.5)*2, (Math.random()-0.5)*6),
          drag: 0.985,
          gravity: -1.0,
          groundBounce: 0.0,
          type: "leaf"
        });
      }
    }

    function updateParticles(dt) {
      for (let i = particles.length - 1; i >= 0; i--) {
        const p = particles[i];

        // integrate
        p.v.y += p.gravity * dt;
        p.v.multiplyScalar(Math.pow(p.drag, dt * 60));

        p.mesh.position.addScaledVector(p.v, dt);

        // spin
        p.mesh.rotation.x += p.spin.x * dt;
        p.mesh.rotation.y += p.spin.y * dt;
        p.mesh.rotation.z += p.spin.z * dt;

        // ground
        if (p.mesh.position.y < 0.02) {
          p.mesh.position.y = 0.02;
          if (p.groundBounce > 0) {
            p.v.y = Math.abs(p.v.y) * p.groundBounce;
            p.v.x *= 0.75;
            p.v.z *= 0.75;
          } else {
            // leaves just rest
            p.v.set(0, 0, 0);
          }
        }

        // life/fade
        p.life -= dt;
        const alpha = Math.max(0, Math.min(1, p.life / p.maxLife));

        // quick fade on chips (material transparency)
        if (p.type === "chip") {
          p.mesh.material.transparent = true;
          p.mesh.material.opacity = alpha;
        } else {
          p.mesh.material.transparent = true;
          p.mesh.material.opacity = alpha;
        }

        if (p.life <= 0) {
          scene.remove(p.mesh);
          particles.splice(i, 1);
        }
      }
    }



    // ---------- Trees ----------
    const trees = [];
    const treeGroup = new THREE.Group();
    scene.add(treeGroup);

    // For raycast, we keep a list of mesh objects that belong to trees
    const treePickMeshes = [];

    function makeTree(name) {
      const g = new THREE.Group();
      g.name = name;
      g.userData.isTree = true;

      // trunk (bottom sits on y=0 because trunk height=2 and centered at y=1)
      const trunk = new THREE.Mesh(
        new THREE.CylinderGeometry(0.25, 0.35, 2.0, 8),
        new THREE.MeshStandardMaterial({ color: 0x6b4a2b, roughness: 1 })
      );
      trunk.position.y = 1.0;
      trunk.userData.treeRoot = g;
      g.add(trunk);

      // leaves
      const leaves = new THREE.Mesh(
        new THREE.ConeGeometry(1.2, 2.8, 10),
        new THREE.MeshStandardMaterial({ color: 0x2f7d46, roughness: 1 })
      );
      leaves.position.y = 3.0;
      leaves.userData.treeRoot = g;
      g.add(leaves);

      // Raycast candidates
      treePickMeshes.push(trunk, leaves);

      // chop + fall state
      g.userData.hp = 1.0;          // 0..1
      g.userData.maxHp = 1.0;
      g.userData.alive = true;

      g.userData.falling = false;
      g.userData.fallT = 0;         // 0..1 over fall duration
      g.userData.fallAxis = new THREE.Vector3(1,0,0);
      g.userData.fallAngle = 0;
      g.userData.removeAt = null;   // time in seconds (clock) to remove after hitting ground

      return g;
    }

    function scatterTrees(count = 70) {
      for (let i = 0; i < count; i++) {
        const t = makeTree("Tree " + (i + 1));
        const x = (Math.random() - 0.5) * 140;
        const z = (Math.random() - 0.5) * 140;

        if (Math.hypot(x, z) < 10) { i--; continue; }

        t.position.set(x, 0, z);
        t.rotation.y = Math.random() * Math.PI * 2;
        const s = 0.8 + Math.random() * 0.6;
        t.scale.set(s, s, s);

        treeGroup.add(t);
        trees.push(t);
      }
    }
    scatterTrees(70);

    // ---------- Wood drops ----------
    const woodDrops = [];
    const woodGroup = new THREE.Group();
    scene.add(woodGroup);

    function spawnWoodDrops(tree, fallDir) {
      const dropCount = 2 + Math.floor(Math.random() * 3); // 2..4
      const logMat = new THREE.MeshStandardMaterial({ color: 0x8a5a34, roughness: 1 });

      for (let i = 0; i < dropCount; i++) {
        const log = new THREE.Mesh(
          new THREE.CylinderGeometry(0.12, 0.12, 0.45, 8),
          logMat
        );
        log.rotation.z = Math.PI * 0.5;
        log.position.copy(tree.position);
        log.position.y = 0.25;
        log.position.addScaledVector(fallDir, 0.6 + Math.random() * 0.8);
        log.position.x += (Math.random() - 0.5) * 0.4;
        log.position.z += (Math.random() - 0.5) * 0.4;

        // simple velocity + gravity
        const v = new THREE.Vector3(
          (Math.random() - 0.5) * 1.2 + fallDir.x * (0.5 + Math.random()),
          2.2 + Math.random() * 1.2,
          (Math.random() - 0.5) * 1.2 + fallDir.z * (0.5 + Math.random())
        );

        log.userData.v = v;
        log.userData.collected = false;

        woodGroup.add(log);
        woodDrops.push(log);
      }
    }

    function updateWoodDrops(dt) {
      const gravity = -8.5;

      for (let i = woodDrops.length - 1; i >= 0; i--) {
        const d = woodDrops[i];
        if (d.userData.collected) continue;

        // physics-lite
        d.userData.v.y += gravity * dt;
        d.position.addScaledVector(d.userData.v, dt);

        // ground collide
        if (d.position.y < 0.18) {
          d.position.y = 0.18;
          d.userData.v.y *= -0.25; // small bounce
          d.userData.v.x *= 0.82;
          d.userData.v.z *= 0.82;

          // stop jitter
          if (Math.abs(d.userData.v.y) < 0.2) d.userData.v.y = 0;
        }

        // spin a bit
        d.rotation.x += dt * 1.8;
        d.rotation.y += dt * 1.1;

        // auto-collect if close to player
        tmpV.copy(d.position).sub(player.position);
        tmpV.y = 0;
        if (tmpV.length() < 1.15) {
          d.userData.collected = true;
          woodGroup.remove(d);
          woodDrops.splice(i, 1);

          wood += 1;
          woodEl.textContent = String(wood);
        }
      }
    }

    // ---------- Targeting (center-screen raycast) ----------
    function pickTreeFromCenter() {
      raycaster.setFromCamera({ x: 0, y: 0 }, camera);
      const hits = raycaster.intersectObjects(treePickMeshes, false);

      if (!hits.length) return null;

      // find first alive tree within range
      const maxDist = 5.0;

      for (const h of hits) {
        const root = h.object.userData.treeRoot;
        if (!root) continue;
        if (!root.userData.alive) continue;
        if (root.userData.falling) continue;

        // distance check from player to tree base
        tmpV.copy(root.position).sub(player.position);
        tmpV.y = 0;
        if (tmpV.length() <= maxDist) return root;
      }

      return null;
    }

    // ---------- Chopping + falling ----------
    const chopRate = 0.60; // hp per second
    const fallDuration = 0.65; // seconds
    const removeDelayAfterFall = 1.1;
    // Chop "hit" cadence (visual + sound)
    let chopHitTimer = 0;
    const chopHitInterval = 0.12; // seconds between bursts while holding



    function startTreeFall(tree) {
      tree.userData.falling = true;
      tree.userData.fallT = 0;
      tree.userData.fallAngle = 0;

      // Fall direction AWAY from player (tree -> away direction)
      tmpV.copy(tree.position).sub(player.position);
      tmpV.y = 0;
      if (tmpV.lengthSq() < 0.0001) tmpV.set(1, 0, 0);
      tmpV.normalize(); // this points from player to tree, so "away from player" for the tree top

      // Axis to rotate around so the tree tips in tmpV direction:
      // rotate around axis perpendicular to UP and fallDir.
      tmpV2.crossVectors(UP, tmpV).normalize();
      if (tmpV2.lengthSq() < 0.0001) tmpV2.set(0, 0, 1);

      tree.userData.fallAxis.copy(tmpV2);

      // Spawn wood after impact (we’ll do it when fall completes)
      tree.userData.fallDir = tmpV.clone();
    }

    function updateFallingTrees(dt, nowSeconds) {
      for (let i = trees.length - 1; i >= 0; i--) {
        const t = trees[i];
        if (!t.userData.alive) continue;

        if (t.userData.falling) {
          t.userData.fallT = Math.min(1, t.userData.fallT + dt / fallDuration);
          const eased = easeOutCubic(t.userData.fallT);

          const targetAngle = Math.PI / 2; // 90 degrees
          const angle = eased * targetAngle;
          t.userData.fallAngle = angle;

          // Apply axis-angle rotation (keep base at y=0)
          t.setRotationFromAxisAngle(t.userData.fallAxis, angle);

          // when impact happens (fallT hits 1), schedule removal + spawn wood once
          if (t.userData.fallT >= 1 && t.userData.removeAt == null) {
            t.userData.removeAt = nowSeconds + removeDelayAfterFall;

            // drop wood in the direction it fell
            playTreeThud();
            spawnWoodDrops(t, t.userData.fallDir || new THREE.Vector3(1,0,0));
          }

          // remove after delay
          if (t.userData.removeAt != null && nowSeconds >= t.userData.removeAt) {
            t.userData.alive = false;
            treeGroup.remove(t);
          }
        }
      }
    }

    // ---------- Movement tuning ----------
    const baseSpeed = 6.0;
    const sprintSpeed = 10.0;
    const turnSpeed = 12.0;


    // --- Mouse-look (pointer lock) ---
    let camYaw = 0;                  // left/right
    let camPitch = -0.35;            // up/down (radians)
    const pitchMin = -0.95;  // less "look straight down"
    const pitchMax = 0.25;
    const mouseSensitivity = 0.0022;

    // Click to lock pointer (required by browser)
    renderer.domElement.addEventListener("click", () => {
      renderer.domElement.focus(); // <-- critical for WASD
      initAudio();
      renderer.domElement.requestPointerLock?.();
    });

    // Update yaw/pitch when pointer is locked
    window.addEventListener("mousemove", (e) => {
      if (document.pointerLockElement !== renderer.domElement) return;

      camYaw   -= e.movementX * mouseSensitivity;
      camPitch += e.movementY * mouseSensitivity; // inverted Y
      camPitch = Math.max(pitchMin, Math.min(pitchMax, camPitch));
    });



    // ---------- Game loop ----------
    function animate() {
      requestAnimationFrame(animate);
      const dt = Math.min(clock.getDelta(), 0.05);
      const nowSeconds = clock.elapsedTime;

      // --- Movement (camera-relative) ---
      const sprint = keys.has("ShiftLeft") || keys.has("ShiftRight");
      const speed = sprint ? sprintSpeed : baseSpeed;

      const move = new THREE.Vector3();

      // Forward/right derived ONLY from mouse-look yaw
      const camForward = new THREE.Vector3(Math.sin(camYaw), 0, Math.cos(camYaw)).normalize();
      const camRight = new THREE.Vector3().crossVectors(camForward, UP).normalize().multiplyScalar(-1);

      if (keys.has("KeyW")) move.add(camForward);
      if (keys.has("KeyS")) move.sub(camForward);
      if (keys.has("KeyA")) move.sub(camRight);
      if (keys.has("KeyD")) move.add(camRight);

      if (move.lengthSq() > 0) {
        move.normalize();

        // Rotate player to face movement direction (camera-relative)
        const targetYaw = Math.atan2(move.x, move.z);
        player.rotation.y = THREE.MathUtils.lerpAngle(
          player.rotation.y,
          targetYaw,
          Math.min(1, turnSpeed * dt)
        );

        // Move strictly in camera-facing direction
        player.position.addScaledVector(move, speed * dt);
      }

      player.position.y = 0;

      // --- Camera (mouse-look orbit behind player) ---
      const camDistance = 10;
      const camHeight   = 2.2;

      // Build an offset from yaw/pitch like an orbit camera
      const offset = new THREE.Vector3(
        Math.sin(camYaw) * Math.cos(camPitch),
        Math.sin(camPitch),
        Math.cos(camYaw) * Math.cos(camPitch)
      ).multiplyScalar(camDistance);

            // Position camera behind/around player
      const desiredCamPos = player.position.clone().add(offset);
      desiredCamPos.y += camHeight;

      // --- Ground collision (simple clamp) ---
      const minCamY = 0.6;              // keep camera above ground
      desiredCamPos.y = Math.max(minCamY, desiredCamPos.y);

      // Smooth camera
      camera.position.lerp(desiredCamPos, 1 - Math.pow(0.001, dt));

      // Look at player (slightly above center)
      camera.lookAt(player.position.x, player.position.y + 1.2, player.position.z);

      // --- Targeting ---
      const target = pickTreeFromCenter();
      targetNameEl.textContent = target ? target.name : "None";

      // --- Chopping ---
      if (target && isChopping) {
        target.userData.hp = clamp01(target.userData.hp - chopRate * dt);

        // crude feedback: wiggle the axe + shake target slightly
        axe.rotation.z = Math.sin(performance.now() * 0.05) * 0.6;
        target.rotation.z = Math.sin(performance.now() * 0.03) * 0.06;

        // Trigger particles + sound at a steady "axe hit" rhythm
        chopHitTimer -= dt;
        if (chopHitTimer <= 0) {
          chopHitTimer = chopHitInterval;

          spawnChopParticles(target);
          playChopSound();
        }

        if (target.userData.hp <= 0 && !target.userData.falling) {
          // count as chopped
          score += 1;
          scoreEl.textContent = String(score);

          // begin fall away from player
          startTreeFall(target);

          // reset so next tree hit starts with an immediate burst
          chopHitTimer = 0;
        }
      } else {
        axe.rotation.z = 0;
        chopHitTimer = 0; // reset cadence when not chopping / no target
      }

      // Update chop bar
      if (target) {
        const pct = (1 - (target.userData.hp / target.userData.maxHp)) * 100;
        barInner.style.width = `${pct.toFixed(1)}%`;
      } else {
        barInner.style.width = `0%`;
      }

      // --- Update falling + drops ---
      updateFallingTrees(dt, nowSeconds);
      updateWoodDrops(dt);
      updateParticles(dt);


      renderer.render(scene, camera);
    }

    animate();

    // ---------- Resize ----------
    window.addEventListener("resize", () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
  </script>
</body>
</html>
