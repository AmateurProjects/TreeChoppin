<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Tree Chopping Prototype</title>
  <style>
    html, body { margin:0; padding:0; overflow:hidden; background:#0b0f12; }
    canvas { display:block; }

    /* Minimal HUD */
    #hud {
      position: fixed;
      left: 12px; top: 12px;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      color: #e8f0f7;
      user-select: none;
      background: rgba(0,0,0,0.35);
      padding: 10px 12px;
      border-radius: 12px;
      backdrop-filter: blur(6px);
      max-width: 340px;
    }
    #hint { font-size: 12px; opacity: 0.9; margin-top: 6px; line-height: 1.3; }
    .statline { margin-top: 6px; font-size: 13px; }
    #score, #wood { font-weight: 800; }

    #chopWrap { margin-top: 10px; }
    #barOuter {
      width: 260px; height: 10px;
      border-radius: 999px;
      background: rgba(255,255,255,0.12);
      overflow: hidden;
    }
    #barInner {
      width: 0%;
      height: 100%;
      background: rgba(120, 220, 120, 0.95);
    }
    #targetLine { font-size: 12px; margin-top: 6px; opacity: 0.9; }
    #centerDot {
      position: fixed; left: 50%; top: 50%;
      width: 6px; height: 6px;
      transform: translate(-50%, -50%);
      border-radius: 50%;
      background: rgba(255,255,255,0.7);
      box-shadow: 0 0 0 3px rgba(0,0,0,0.25);
      pointer-events: none;
    }
  </style>
</head>
<body>
  <div id="hud">
    <div class="statline">Score: <span id="score">0</span> &nbsp;•&nbsp; Wood: <span id="wood">0</span></div>
    <div id="hint">
      Move: <b>WASD</b> • Sprint: <b>Shift</b> • Chop: <b>Hold Left Click</b><br/>
      Aim at a tree (center dot), get close, and chop.
    </div>
    <div id="chopWrap">
      <div id="barOuter"><div id="barInner"></div></div>
      <div id="targetLine">Target: <span id="targetName">None</span></div>
    </div>
  </div>
  <div id="centerDot"></div>

  <script type="module">
    import * as THREE from "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js";

    // ---------- Basic setup ----------
    const scene = new THREE.Scene();

    // Blue sky background
    scene.background = new THREE.Color(0x78b7ff);

    // Softer fog (optional, keep it light so it doesn’t darken the scene)
    scene.fog = new THREE.Fog(0x78b7ff, 140, 520);

    const camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 500);
    camera.position.set(0, 6, 10);

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
    document.body.appendChild(renderer.domElement);
    renderer.domElement.tabIndex = 0;           // make canvas focusable
    renderer.domElement.style.outline = "none"; // no focus ring
    renderer.domElement.focus();

    // ---------- Lights ----------
    // Sky + ground bounce lighting (very outdoor-looking)
    const hemi = new THREE.HemisphereLight(0xbfdcff, 0x2a4a2a, 0.95);
    scene.add(hemi);

    // Sun light
    const sun = new THREE.DirectionalLight(0xffffff, 1.25);
    sun.position.set(80, 140, 60);
    sun.castShadow = false; // keep simple for now
    scene.add(sun);

    // Visible sun disc in the sky (simple)
    const sunDisc = new THREE.Mesh(
      new THREE.SphereGeometry(6, 24, 16),
      new THREE.MeshBasicMaterial({ color: 0xfff2b0 })
    );
    sunDisc.position.copy(sun.position);
    scene.add(sunDisc);


    // ---------- Ground (rolling hills) ----------
    const groundSize = 520;
    const groundSegs = 220;

    // More segments = smoother hills
    const groundGeo = new THREE.PlaneGeometry(groundSize, groundSize, groundSegs, groundSegs);
    groundGeo.rotateX(-Math.PI / 2);

    // Lightweight 2D value-noise (no external libs)
    function hash2(x, z) {
      // deterministic pseudo-random 0..1
      const s = Math.sin(x * 127.1 + z * 311.7) * 43758.5453123;
      return s - Math.floor(s);
    }
    function smoothstep(t) { return t * t * (3 - 2 * t); }
    function lerp(a, b, t) { return a + (b - a) * t; }

    function valueNoise2D(x, z) {
      const x0 = Math.floor(x), z0 = Math.floor(z);
      const x1 = x0 + 1,       z1 = z0 + 1;

      const sx = smoothstep(x - x0);
      const sz = smoothstep(z - z0);

      const n00 = hash2(x0, z0);
      const n10 = hash2(x1, z0);
      const n01 = hash2(x0, z1);
      const n11 = hash2(x1, z1);

      const ix0 = lerp(n00, n10, sx);
      const ix1 = lerp(n01, n11, sx);
      return lerp(ix0, ix1, sz);
    }

    // Fractal noise (octaves) for nicer hills
    function fbm(x, z) {
      let amp = 1.0;
      let freq = 0.035;
      let sum = 0.0;
      let norm = 0.0;

      for (let i = 0; i < 5; i++) {
        sum += (valueNoise2D(x * freq, z * freq) * 2 - 1) * amp;
        norm += amp;
        amp *= 0.5;
        freq *= 2.0;
      }
      return sum / norm; // ~ -1..1
    }

    const HILL_HEIGHT = 7.0;

    function getGroundHeight(x, z) {
      return fbm(x, z) * HILL_HEIGHT;
    }

    // Approximate ground normal using finite differences
    function getGroundNormal(x, z) {
      const eps = 0.75;
      const hL = getGroundHeight(x - eps, z);
      const hR = getGroundHeight(x + eps, z);
      const hD = getGroundHeight(x, z - eps);
      const hU = getGroundHeight(x, z + eps);

      const n = new THREE.Vector3(hL - hR, 2 * eps, hD - hU);
      return n.normalize();
    }


    // Displace vertices in Y
    const pos = groundGeo.attributes.position;
    for (let i = 0; i < pos.count; i++) {
      const x = pos.getX(i);
      const z = pos.getZ(i);

      // Rolling hills: broad + gentle
      const h = fbm(x, z);
      const height = h * HILL_HEIGHT;

      pos.setY(i, height);
    }
    pos.needsUpdate = true;
    groundGeo.computeVertexNormals();

    // Grass material
    const groundMat = new THREE.MeshStandardMaterial({
      color: 0x2f8f3f,      // grass green
      roughness: 1.0,
      metalness: 0.0
    });

    const ground = new THREE.Mesh(groundGeo, groundMat);
    ground.position.y = 0;
    scene.add(ground);

    // Rocks (sit on hills + align to slope)
    const rockMat = new THREE.MeshStandardMaterial({ color: 0x2b2f33, roughness: 1 });
    for (let i = 0; i < 30; i++) {
      const size = 0.4 + Math.random() * 0.8;
      const g = new THREE.DodecahedronGeometry(size);
      g.computeBoundingSphere();
      const r = g.boundingSphere ? g.boundingSphere.radius : size;

      const m = new THREE.Mesh(g, rockMat);

      const x = (Math.random() - 0.5) * 120;
      const z = (Math.random() - 0.5) * 120;

      const y = getGroundHeight(x, z);
      const n = getGroundNormal(x, z);

      // Place rock so it rests on surface (center lifted by radius)
      m.position.set(x, y + r * 0.9, z);

      // Align "up" to slope normal, then random twist around that normal
      m.quaternion.setFromUnitVectors(new THREE.Vector3(0, 1, 0), n);
      m.quaternion.premultiply(new THREE.Quaternion().setFromAxisAngle(n, Math.random() * Math.PI * 2));

      scene.add(m);
    }

    // ---------- Player ----------
    const player = new THREE.Group();
    scene.add(player);

    const bodyGeo = new THREE.CapsuleGeometry(0.45, 0.8, 6, 10);
    const bodyMat = new THREE.MeshStandardMaterial({ color: 0x7aa7ff, roughness: 0.7 });
    const body = new THREE.Mesh(bodyGeo, bodyMat);
    body.position.y = 0.9;
    player.add(body);

    const axeGeo = new THREE.BoxGeometry(0.1, 0.6, 0.1);
    const axeMat = new THREE.MeshStandardMaterial({ color: 0xd9d9d9, roughness: 0.4 });
    const axe = new THREE.Mesh(axeGeo, axeMat);
    axe.position.set(0.55, 1.1, 0.2);
    player.add(axe);

    player.position.set(0, 0, 0);

    // ---------- UI ----------
    const scoreEl = document.getElementById("score");
    const woodEl = document.getElementById("wood");
    const barInner = document.getElementById("barInner");
    const targetNameEl = document.getElementById("targetName");
    const hud = document.getElementById("hud");




    let score = 0;
    let wood = 0;

    // ---------- Input ----------
    const keys = new Set();

    document.addEventListener("keydown", (e) => {
      // Keep focus / pointer lock stable and stop browser shortcuts
      if (["KeyW","KeyA","KeyS","KeyD","ShiftLeft","ShiftRight","Space",
          "ArrowUp","ArrowDown","ArrowLeft","ArrowRight"].includes(e.code)) {
        e.preventDefault();
      }
      keys.add(e.code);
    }, { passive: false });

    document.addEventListener("keyup", (e) => {
      keys.delete(e.code);
    });

    // Avoid "stuck keys" if the tab loses focus
    window.addEventListener("blur", () => keys.clear());

    let isChopping = false;
    window.addEventListener("mousedown", (e) => { if (e.button === 0) isChopping = true; });
    window.addEventListener("mouseup", (e) => { if (e.button === 0) isChopping = false; });

    // ---------- Audio (procedural WebAudio) ----------
    let audioCtx = null;
    let masterGain = null;

    function initAudio() {
      if (audioCtx) return;
      audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      masterGain = audioCtx.createGain();
      masterGain.gain.value = 0.25;
      masterGain.connect(audioCtx.destination);
    }

    function playChopSound() {
      if (!audioCtx) return;

      const t = audioCtx.currentTime;

      // Short "thunk": oscillator + quick envelope
      const osc = audioCtx.createOscillator();
      osc.type = "triangle";
      osc.frequency.setValueAtTime(180 + Math.random() * 60, t);
      osc.frequency.exponentialRampToValueAtTime(90 + Math.random() * 30, t + 0.06);

      const gain = audioCtx.createGain();
      gain.gain.setValueAtTime(0.0001, t);
      gain.gain.exponentialRampToValueAtTime(0.25 + Math.random() * 0.12, t + 0.01);
      gain.gain.exponentialRampToValueAtTime(0.0001, t + 0.09);

      // Add a little noise "crunch" for wood fibers
      const noise = audioCtx.createBufferSource();
      const buffer = audioCtx.createBuffer(1, audioCtx.sampleRate * 0.12, audioCtx.sampleRate);
      const data = buffer.getChannelData(0);
      for (let i = 0; i < data.length; i++) data[i] = (Math.random() * 2 - 1) * 0.6;
      noise.buffer = buffer;

      const noiseFilter = audioCtx.createBiquadFilter();
      noiseFilter.type = "bandpass";
      noiseFilter.frequency.setValueAtTime(900 + Math.random() * 400, t);
      noiseFilter.Q.setValueAtTime(1.5, t);

      const noiseGain = audioCtx.createGain();
      noiseGain.gain.setValueAtTime(0.0001, t);
      noiseGain.gain.exponentialRampToValueAtTime(0.10 + Math.random() * 0.06, t + 0.01);
      noiseGain.gain.exponentialRampToValueAtTime(0.0001, t + 0.08);

      osc.connect(gain);
      gain.connect(masterGain);

      noise.connect(noiseFilter);
      noiseFilter.connect(noiseGain);
      noiseGain.connect(masterGain);

      osc.start(t);
      osc.stop(t + 0.12);

      noise.start(t);
      noise.stop(t + 0.12);
    }

    function playTreeThud() {
      if (!audioCtx) return;
      const t = audioCtx.currentTime;

      const osc = audioCtx.createOscillator();
      osc.type = "sine";
      osc.frequency.setValueAtTime(80, t);
      osc.frequency.exponentialRampToValueAtTime(45, t + 0.18);

      const gain = audioCtx.createGain();
      gain.gain.setValueAtTime(0.0001, t);
      gain.gain.exponentialRampToValueAtTime(0.35, t + 0.01);
      gain.gain.exponentialRampToValueAtTime(0.0001, t + 0.25);

      osc.connect(gain);
      gain.connect(masterGain);

      osc.start(t);
      osc.stop(t + 0.28);
    }



    // ---------- Helpers ----------
    const clock = new THREE.Clock();
    const raycaster = new THREE.Raycaster();
    const tmpV = new THREE.Vector3();
    const tmpV2 = new THREE.Vector3();
    const UP = new THREE.Vector3(0, 1, 0);

    function clamp01(x){ return Math.max(0, Math.min(1, x)); }
    function easeOutCubic(t){ return 1 - Math.pow(1 - t, 3); }

    // three r160-safe angle lerp (shortest path)
    function lerpAngle(a, b, t) {
      const TWO_PI = Math.PI * 2;
      let delta = (b - a) % TWO_PI;
      if (delta > Math.PI) delta -= TWO_PI;
      if (delta < -Math.PI) delta += TWO_PI;
      return a + delta * t;
    }

    // ---------- Particles (woodchips + leaves) ----------
    const particles = []; // { mesh, v, life, maxLife, spin, drag, gravity, groundBounce, type }

    const woodChipMat = new THREE.MeshStandardMaterial({ color: 0x9a6b3a, roughness: 1 });
    const leafMat     = new THREE.MeshStandardMaterial({ color: 0x2f7d46, roughness: 1, side: THREE.DoubleSide });

    const woodChipGeo = new THREE.BoxGeometry(0.06, 0.02, 0.02);
    const leafGeo     = new THREE.PlaneGeometry(0.08, 0.10);

    function spawnChopParticles(tree) {
      // spawn at about chest height near trunk
      const origin = tree.position.clone();
      origin.y = tree.position.y + 1.2;

      // determine a direction from player -> tree (chips fly away from trunk face)
      tmpV.copy(tree.position).sub(player.position);
      tmpV.y = 0;
      if (tmpV.lengthSq() < 0.0001) tmpV.set(0, 0, 1);
      tmpV.normalize();

      // --- woodchips (fast) ---
      const chipCount = 10 + Math.floor(Math.random() * 8);
      for (let i = 0; i < chipCount; i++) {
        const m = new THREE.Mesh(woodChipGeo, woodChipMat);
        m.position.copy(origin);
        m.position.x += (Math.random() - 0.5) * 0.18;
        m.position.y += (Math.random() - 0.5) * 0.20;
        m.position.z += (Math.random() - 0.5) * 0.18;

        // velocity: mostly outward + up
        const v = new THREE.Vector3(
          tmpV.x * (2.0 + Math.random() * 2.5) + (Math.random() - 0.5) * 1.5,
          2.0 + Math.random() * 2.5,
          tmpV.z * (2.0 + Math.random() * 2.5) + (Math.random() - 0.5) * 1.5
        );

        m.rotation.set(Math.random() * Math.PI, Math.random() * Math.PI, Math.random() * Math.PI);

        scene.add(m);
        particles.push({
          mesh: m,
          v,
          life: 0.45 + Math.random() * 0.25,
          maxLife: 0.7,
          spin: new THREE.Vector3((Math.random()-0.5)*14, (Math.random()-0.5)*14, (Math.random()-0.5)*14),
          drag: 0.88,
          gravity: -12.0,
          groundBounce: 0.25,
          type: "chip"
        });
      }

      // --- leaves (slow + floaty) ---
      const leafCount = 6 + Math.floor(Math.random() * 6);
      for (let i = 0; i < leafCount; i++) {
        const m = new THREE.Mesh(leafGeo, leafMat);
        m.position.copy(origin);
        m.position.y += 1.3 + Math.random() * 0.8; // originate higher
        m.position.x += (Math.random() - 0.5) * 0.9;
        m.position.z += (Math.random() - 0.5) * 0.9;

        // leaves drift down
        const v = new THREE.Vector3(
          (Math.random() - 0.5) * 0.8 + tmpV.x * 0.3,
          -0.2 - Math.random() * 0.6,
          (Math.random() - 0.5) * 0.8 + tmpV.z * 0.3
        );

        m.rotation.set(0, Math.random() * Math.PI * 2, Math.random() * Math.PI * 2);

        scene.add(m);
        particles.push({
          mesh: m,
          v,
          life: 1.6 + Math.random() * 1.1,
          maxLife: 2.8,
          spin: new THREE.Vector3((Math.random()-0.5)*3, (Math.random()-0.5)*2, (Math.random()-0.5)*6),
          drag: 0.985,
          gravity: -1.0,
          groundBounce: 0.0,
          type: "leaf"
        });
      }
    }

    function updateParticles(dt) {
      for (let i = particles.length - 1; i >= 0; i--) {
        const p = particles[i];

        // integrate
        p.v.y += p.gravity * dt;
        p.v.multiplyScalar(Math.pow(p.drag, dt * 60));

        p.mesh.position.addScaledVector(p.v, dt);

        // spin
        p.mesh.rotation.x += p.spin.x * dt;
        p.mesh.rotation.y += p.spin.y * dt;
        p.mesh.rotation.z += p.spin.z * dt;

        // ground
        const gy = getGroundHeight(p.mesh.position.x, p.mesh.position.z) + 0.02;
        if (p.mesh.position.y < gy) {
          p.mesh.position.y = gy;
          if (p.groundBounce > 0) {
            p.v.y = Math.abs(p.v.y) * p.groundBounce;
            p.v.x *= 0.75;
            p.v.z *= 0.75;
          } else {
            // leaves just rest
            p.v.set(0, 0, 0);
          }
        }

        // life/fade
        p.life -= dt;
        const alpha = Math.max(0, Math.min(1, p.life / p.maxLife));

        // quick fade on chips (material transparency)
        if (p.type === "chip") {
          p.mesh.material.transparent = true;
          p.mesh.material.opacity = alpha;
        } else {
          p.mesh.material.transparent = true;
          p.mesh.material.opacity = alpha;
        }

        if (p.life <= 0) {
          scene.remove(p.mesh);
          particles.splice(i, 1);
        }
      }
    }



    // ---------- Trees ----------
    const trees = [];
    const treeGroup = new THREE.Group();
    scene.add(treeGroup);

    // For raycast, we keep a list of mesh objects that belong to trees
    const treePickMeshes = [];

    function makeTree(name) {
      const g = new THREE.Group();
      g.name = name;
      g.userData.isTree = true;

      // trunk (bottom sits on y=0 because trunk height=2 and centered at y=1)
      const trunk = new THREE.Mesh(
        new THREE.CylinderGeometry(0.25, 0.35, 2.0, 8),
        new THREE.MeshStandardMaterial({ color: 0x6b4a2b, roughness: 1 })
      );
      trunk.position.y = 1.0;
      trunk.userData.treeRoot = g;
      g.add(trunk);

      // leaves
      const leaves = new THREE.Mesh(
        new THREE.ConeGeometry(1.2, 2.8, 10),
        new THREE.MeshStandardMaterial({ color: 0x2f7d46, roughness: 1 })
      );
      leaves.position.y = 3.0;
      leaves.userData.treeRoot = g;
      g.add(leaves);

      // Raycast candidates
      treePickMeshes.push(trunk, leaves);

      // chop + fall state
      g.userData.hp = 1.0;          // 0..1
      g.userData.maxHp = 1.0;
      g.userData.alive = true;

      g.userData.falling = false;
      g.userData.fallT = 0;         // 0..1 over fall duration
      g.userData.fallAxis = new THREE.Vector3(1,0,0);
      g.userData.fallAngle = 0;
      g.userData.removeAt = null;   // time in seconds (clock) to remove after hitting ground

      return g;
    }

    function scatterTrees(count = 70) {
      for (let i = 0; i < count; i++) {
        const t = makeTree("Tree " + (i + 1));
        const x = (Math.random() - 0.5) * 140;
        const z = (Math.random() - 0.5) * 140;

        if (Math.hypot(x, z) < 10) { i--; continue; }

        // Sit tree base on terrain
        const y = getGroundHeight(x, z);
        const n = getGroundNormal(x, z);

        t.position.set(x, y, z);

        // Align tree "up" to slope normal
        t.quaternion.setFromUnitVectors(new THREE.Vector3(0, 1, 0), n);

        // Random twist around the slope normal (so forests don’t look uniform)
        t.quaternion.premultiply(new THREE.Quaternion().setFromAxisAngle(n, Math.random() * Math.PI * 2));

        const s = 0.8 + Math.random() * 0.6;
        t.scale.set(s, s, s);

        treeGroup.add(t);
        trees.push(t);
      }
    }
    scatterTrees(70);

    // ---------- Wood drops ----------
    const woodDrops = [];
    const woodGroup = new THREE.Group();
    scene.add(woodGroup);

    function spawnWoodDrops(tree, fallDir) {
      const dropCount = 2 + Math.floor(Math.random() * 3); // 2..4
      const logMat = new THREE.MeshStandardMaterial({ color: 0x8a5a34, roughness: 1 });

      for (let i = 0; i < dropCount; i++) {
        const log = new THREE.Mesh(
          new THREE.CylinderGeometry(0.12, 0.12, 0.45, 8),
          logMat
        );
        log.rotation.z = Math.PI * 0.5;
        log.position.copy(tree.position);
        log.position.y = tree.position.y + 0.25;
        log.position.addScaledVector(fallDir, 0.6 + Math.random() * 0.8);
        log.position.x += (Math.random() - 0.5) * 0.4;
        log.position.z += (Math.random() - 0.5) * 0.4;

        // simple velocity + gravity
        const v = new THREE.Vector3(
          (Math.random() - 0.5) * 1.2 + fallDir.x * (0.5 + Math.random()),
          2.2 + Math.random() * 1.2,
          (Math.random() - 0.5) * 1.2 + fallDir.z * (0.5 + Math.random())
        );

        log.userData.v = v;
        log.userData.collected = false;

        woodGroup.add(log);
        woodDrops.push(log);
      }
    }

    function updateWoodDrops(dt) {
      const gravity = -8.5;

      for (let i = woodDrops.length - 1; i >= 0; i--) {
        const d = woodDrops[i];
        if (d.userData.collected) continue;

        // physics-lite
        d.userData.v.y += gravity * dt;
        d.position.addScaledVector(d.userData.v, dt);

        // ground collide
        const gy = getGroundHeight(d.position.x, d.position.z) + 0.18;
        if (d.position.y < gy) {
          d.position.y = gy;
          d.userData.v.y *= -0.25; // small bounce
          d.userData.v.x *= 0.82;
          d.userData.v.z *= 0.82;

          // stop jitter
          if (Math.abs(d.userData.v.y) < 0.2) d.userData.v.y = 0;
        }

        // spin a bit
        d.rotation.x += dt * 1.8;
        d.rotation.y += dt * 1.1;

        // auto-collect if close to player
        tmpV.copy(d.position).sub(player.position);
        tmpV.y = 0;
        if (tmpV.length() < 1.15) {
          d.userData.collected = true;
          woodGroup.remove(d);
          woodDrops.splice(i, 1);

          wood += 1;
          woodEl.textContent = String(wood);
        }
      }
    }

    // ---------- Targeting (center-screen raycast) ----------
    function pickTreeFromCenter() {
      raycaster.setFromCamera({ x: 0, y: 0 }, camera);
      const hits = raycaster.intersectObjects(treePickMeshes, false);

      if (!hits.length) return null;

      // find first alive tree within range
      const maxDist = 5.0;

      for (const h of hits) {
        const root = h.object.userData.treeRoot;
        if (!root) continue;
        if (!root.userData.alive) continue;
        if (root.userData.falling) continue;

        // distance check from player to tree base
        tmpV.copy(root.position).sub(player.position);
        tmpV.y = 0;
        if (tmpV.length() <= maxDist) return root;
      }

      return null;
    }

    // ---------- Chopping + falling ----------
    const chopRate = 0.60; // hp per second
    const fallDuration = 0.65; // seconds
    const removeDelayAfterFall = 1.1;
    // Chop "hit" cadence (visual + sound)
    let chopHitTimer = 0;
    const chopHitInterval = 0.12; // seconds between bursts while holding



    function startTreeFall(tree) {
      tree.userData.falling = true;
      tree.userData.fallT = 0;
      tree.userData.fallAngle = 0;

      // Fall direction AWAY from player (tree -> away direction)
      tmpV.copy(tree.position).sub(player.position);
      tmpV.y = 0;
      if (tmpV.lengthSq() < 0.0001) tmpV.set(1, 0, 0);
      tmpV.normalize(); // this points from player to tree, so "away from player" for the tree top

      // Axis to rotate around so the tree tips in tmpV direction:
      // rotate around axis perpendicular to UP and fallDir.
      tmpV2.crossVectors(UP, tmpV).normalize();
      if (tmpV2.lengthSq() < 0.0001) tmpV2.set(0, 0, 1);

      tree.userData.fallAxis.copy(tmpV2);

      // Spawn wood after impact (we’ll do it when fall completes)
      tree.userData.fallDir = tmpV.clone();
    }

    function updateFallingTrees(dt, nowSeconds) {
      for (let i = trees.length - 1; i >= 0; i--) {
        const t = trees[i];
        if (!t.userData.alive) continue;

        if (t.userData.falling) {
          t.userData.fallT = Math.min(1, t.userData.fallT + dt / fallDuration);
          const eased = easeOutCubic(t.userData.fallT);

          const targetAngle = Math.PI / 2; // 90 degrees
          const angle = eased * targetAngle;
          t.userData.fallAngle = angle;

          // Apply axis-angle rotation (keep base at y=0)
          t.setRotationFromAxisAngle(t.userData.fallAxis, angle);

          // when impact happens (fallT hits 1), schedule removal + spawn wood once
          if (t.userData.fallT >= 1 && t.userData.removeAt == null) {
            t.userData.removeAt = nowSeconds + removeDelayAfterFall;

            // drop wood in the direction it fell
            playTreeThud();
            spawnWoodDrops(t, t.userData.fallDir || new THREE.Vector3(1,0,0));
          }

          // remove after delay
          if (t.userData.removeAt != null && nowSeconds >= t.userData.removeAt) {
            t.userData.alive = false;
            treeGroup.remove(t);
          }
        }
      }
    }

    // ---------- Movement tuning ----------
    const baseSpeed = 6.0;
    const sprintSpeed = 10.0;
    const turnSpeed = 12.0;

    // ---------- Jump / gravity ----------
    let playerVy = 0;                // vertical velocity
    let isGrounded = false;
    const jumpSpeed = 6.4;           // jump impulse
    const gravity = -18.0;           // downward accel (units/s^2)


    // --- Mouse-look (pointer lock) ---
    let camYaw = 0;                  // left/right
    let camPitch = -0.35;            // up/down (radians)
    const pitchMin = -1.15;          // can look further down
    const pitchMax = 0.85;           // can look much further up
    const mouseSensitivity = 0.0022;

    // Click to lock pointer (required by browser)
    renderer.domElement.addEventListener("click", () => {
      renderer.domElement.focus(); // <-- critical for WASD
      initAudio();
      renderer.domElement.requestPointerLock?.();
    });

    // Update yaw/pitch when pointer is locked
    window.addEventListener("mousemove", (e) => {
      if (document.pointerLockElement !== renderer.domElement) return;

      camYaw   -= e.movementX * mouseSensitivity;
      camPitch += e.movementY * mouseSensitivity; // inverted Y
      camPitch = Math.max(pitchMin, Math.min(pitchMax, camPitch));
    });



    // ---------- Game loop ----------
    function animate() {
      requestAnimationFrame(animate);
      
      try {
      const dt = Math.min(clock.getDelta(), 0.05);
      const nowSeconds = clock.elapsedTime;

      // --- Movement (camera-relative) ---
      const sprint = keys.has("ShiftLeft") || keys.has("ShiftRight");
      const speed = sprint ? sprintSpeed : baseSpeed;

      const move = new THREE.Vector3();

      // Forward/right derived ONLY from mouse-look yaw
      const camForward = new THREE.Vector3(
        -Math.sin(camYaw), 0, -Math.cos(camYaw)
      ).normalize();
        const camRight = new THREE.Vector3()
          .crossVectors(camForward, UP)
          .normalize();

      if (keys.has("KeyW")) move.add(camForward);
      if (keys.has("KeyS")) move.sub(camForward);
      if (keys.has("KeyA")) move.sub(camRight);
      if (keys.has("KeyD")) move.add(camRight);

      if (move.lengthSq() > 0) {
        move.normalize();

        // Rotate player to face movement direction (camera-relative)
        const targetYaw = Math.atan2(move.x, move.z);
        player.rotation.y = lerpAngle(
          player.rotation.y,
          targetYaw,
          Math.min(1, turnSpeed * dt)
        );


        // Move strictly in camera-facing direction
        player.position.addScaledVector(move, speed * dt);
      }

        // Ground height under player (terrain)
        const groundY = getGroundHeight(player.position.x, player.position.z);

        // Jump (Space) only when grounded
        if (keys.has("Space") && isGrounded) {
          playerVy = jumpSpeed;
          isGrounded = false;
        }

        // Gravity integration
        playerVy += gravity * dt;
        player.position.y += playerVy * dt;

        // Ground collision / landing
        if (player.position.y <= groundY) {
          player.position.y = groundY;
          playerVy = 0;
          isGrounded = true;
        }

      // --- Camera (mouse-look orbit behind player) ---
      const camDistance = 10;
      const camHeight   = 2.2;

      // Build an offset from yaw/pitch like an orbit camera
      const offset = new THREE.Vector3(
        Math.sin(camYaw) * Math.cos(camPitch),
        Math.sin(camPitch),
        Math.cos(camYaw) * Math.cos(camPitch)
      ).multiplyScalar(camDistance);

            // Position camera behind/around player
      const desiredCamPos = player.position.clone().add(offset);
      desiredCamPos.y += camHeight;

      // --- Ground collision (simple clamp) ---
      const minCamY = 0.6;              // keep camera above ground
      desiredCamPos.y = Math.max(minCamY, desiredCamPos.y);

      // Smooth camera
      camera.position.lerp(desiredCamPos, 1 - Math.pow(0.001, dt));

      // Look at player (slightly above center)
      camera.lookAt(player.position.x, player.position.y + 1.2, player.position.z);

      // --- Targeting ---
      const target = pickTreeFromCenter();
      targetNameEl.textContent = target ? target.name : "None";

      // --- Chopping ---
      if (target && isChopping) {
        target.userData.hp = clamp01(target.userData.hp - chopRate * dt);

        // crude feedback: wiggle the axe + shake target slightly
        axe.rotation.z = Math.sin(performance.now() * 0.05) * 0.6;
        target.rotation.z = Math.sin(performance.now() * 0.03) * 0.06;

        // Trigger particles + sound at a steady "axe hit" rhythm
        chopHitTimer -= dt;
        if (chopHitTimer <= 0) {
          chopHitTimer = chopHitInterval;

          spawnChopParticles(target);
          playChopSound();
        }

        if (target.userData.hp <= 0 && !target.userData.falling) {
          // count as chopped
          score += 1;
          scoreEl.textContent = String(score);

          // begin fall away from player
          startTreeFall(target);

          // reset so next tree hit starts with an immediate burst
          chopHitTimer = 0;
        }
      } else {
        axe.rotation.z = 0;
        chopHitTimer = 0; // reset cadence when not chopping / no target
      }

      // Update chop bar
      if (target) {
        const pct = (1 - (target.userData.hp / target.userData.maxHp)) * 100;
        barInner.style.width = `${pct.toFixed(1)}%`;
      } else {
        barInner.style.width = `0%`;
      }

      // --- Update falling + drops ---
      updateFallingTrees(dt, nowSeconds);
      updateWoodDrops(dt);
      updateParticles(dt);


      renderer.render(scene, camera);

      } catch (err) {
        console.error(err);
        const hud = document.getElementById("hud");
        if (hud) {
          hud.innerHTML = `
            <div style="font-weight:800;color:#ffb4b4">Runtime error</div>
            <div style="font-size:12px;white-space:pre-wrap">${String(err)}</div>
          `;
        }
      }
    }

    animate();      


    // ---------- Resize ----------
    window.addEventListener("resize", () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
  </script>
</body>
</html>
