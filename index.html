<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Tree Chopping Prototype</title>
  <style>
    html, body { margin:0; padding:0; overflow:hidden; background:#0b0f12; }
    canvas { display:block; }

    /* Minimal HUD */
    #hud {
      position: fixed;
      left: 12px; top: 12px;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      color: #e8f0f7;
      user-select: none;
      background: rgba(0,0,0,0.35);
      padding: 10px 12px;
      border-radius: 12px;
      backdrop-filter: blur(6px);
      max-width: 320px;
    }
    #hint { font-size: 12px; opacity: 0.9; margin-top: 6px; line-height: 1.3; }
    #score { font-weight: 700; }
    #chopWrap { margin-top: 10px; }
    #barOuter {
      width: 240px; height: 10px;
      border-radius: 999px;
      background: rgba(255,255,255,0.12);
      overflow: hidden;
    }
    #barInner {
      width: 0%;
      height: 100%;
      background: rgba(120, 220, 120, 0.95);
    }
    #targetLine { font-size: 12px; margin-top: 6px; opacity: 0.9; }
    #centerDot {
      position: fixed; left: 50%; top: 50%;
      width: 6px; height: 6px;
      transform: translate(-50%, -50%);
      border-radius: 50%;
      background: rgba(255,255,255,0.7);
      box-shadow: 0 0 0 3px rgba(0,0,0,0.25);
      pointer-events: none;
    }
  </style>
</head>
<body>
  <div id="hud">
    <div>Score: <span id="score">0</span></div>
    <div id="hint">
      Move: <b>WASD</b> • Sprint: <b>Shift</b> • Chop: <b>Hold Left Click</b><br/>
      Get close to a tree, face it, and chop.
    </div>
    <div id="chopWrap">
      <div id="barOuter"><div id="barInner"></div></div>
      <div id="targetLine">Target: <span id="targetName">None</span></div>
    </div>
  </div>
  <div id="centerDot"></div>

  <!-- Three.js (module) -->
  <script type="module">
    import * as THREE from "https://unpkg.com/three@0.160.0/build/three.module.js";

    // ---------- Basic setup ----------
    const scene = new THREE.Scene();
    scene.fog = new THREE.Fog(0x0b0f12, 30, 130);

    const camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 500);
    camera.position.set(0, 6, 10);

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
    document.body.appendChild(renderer.domElement);

    // ---------- Lights ----------
    scene.add(new THREE.AmbientLight(0xffffff, 0.35));

    const sun = new THREE.DirectionalLight(0xffffff, 1.0);
    sun.position.set(20, 40, 10);
    scene.add(sun);

    // ---------- Ground ----------
    const groundGeo = new THREE.PlaneGeometry(400, 400, 1, 1);
    const groundMat = new THREE.MeshStandardMaterial({ color: 0x1b2320, roughness: 1, metalness: 0 });
    const ground = new THREE.Mesh(groundGeo, groundMat);
    ground.rotation.x = -Math.PI / 2;
    ground.position.y = 0;
    scene.add(ground);

    // Add a few crude rocks
    const rockMat = new THREE.MeshStandardMaterial({ color: 0x2b2f33, roughness: 1 });
    for (let i = 0; i < 30; i++) {
      const g = new THREE.DodecahedronGeometry(0.4 + Math.random() * 0.8);
      const m = new THREE.Mesh(g, rockMat);
      m.position.set((Math.random() - 0.5) * 120, 0.4, (Math.random() - 0.5) * 120);
      m.rotation.set(Math.random()*2, Math.random()*2, Math.random()*2);
      scene.add(m);
    }

    // ---------- Player ----------
    const player = new THREE.Group();
    scene.add(player);

    // crude body
    const bodyGeo = new THREE.CapsuleGeometry(0.45, 0.8, 6, 10);
    const bodyMat = new THREE.MeshStandardMaterial({ color: 0x7aa7ff, roughness: 0.7 });
    const body = new THREE.Mesh(bodyGeo, bodyMat);
    body.position.y = 0.9;
    player.add(body);

    // crude "axe" indicator
    const axeGeo = new THREE.BoxGeometry(0.1, 0.6, 0.1);
    const axeMat = new THREE.MeshStandardMaterial({ color: 0xd9d9d9, roughness: 0.4 });
    const axe = new THREE.Mesh(axeGeo, axeMat);
    axe.position.set(0.55, 1.1, 0.2);
    player.add(axe);

    player.position.set(0, 0, 0);

    // ---------- Trees ----------
    const trees = [];
    const treeGroup = new THREE.Group();
    scene.add(treeGroup);

    function makeTree(name) {
      const g = new THREE.Group();
      g.name = name;

      // trunk
      const trunk = new THREE.Mesh(
        new THREE.CylinderGeometry(0.25, 0.35, 2.0, 8),
        new THREE.MeshStandardMaterial({ color: 0x6b4a2b, roughness: 1 })
      );
      trunk.position.y = 1.0;
      g.add(trunk);

      // leaves
      const leaves = new THREE.Mesh(
        new THREE.ConeGeometry(1.2, 2.8, 10),
        new THREE.MeshStandardMaterial({ color: 0x2f7d46, roughness: 1 })
      );
      leaves.position.y = 3.0;
      g.add(leaves);

      // chop state
      g.userData.hp = 1.0;          // 0..1
      g.userData.maxHp = 1.0;
      g.userData.alive = true;

      return g;
    }

    function scatterTrees(count = 60) {
      for (let i = 0; i < count; i++) {
        const t = makeTree("Tree " + (i + 1));
        const x = (Math.random() - 0.5) * 140;
        const z = (Math.random() - 0.5) * 140;

        // keep spawn area a bit clear near player
        if (Math.hypot(x, z) < 10) { i--; continue; }

        t.position.set(x, 0, z);
        t.rotation.y = Math.random() * Math.PI * 2;
        const s = 0.8 + Math.random() * 0.6;
        t.scale.set(s, s, s);

        treeGroup.add(t);
        trees.push(t);
      }
    }
    scatterTrees(70);

    // ---------- Input ----------
    const keys = new Set();
    window.addEventListener("keydown", (e) => keys.add(e.code));
    window.addEventListener("keyup", (e) => keys.delete(e.code));

    let isChopping = false;
    window.addEventListener("mousedown", (e) => {
      if (e.button === 0) isChopping = true;
    });
    window.addEventListener("mouseup", (e) => {
      if (e.button === 0) isChopping = false;
    });

    // Pointer lock (optional)
    // If you want mouse-look later, we can enable pointer lock on click.

    // ---------- UI ----------
    const scoreEl = document.getElementById("score");
    const barInner = document.getElementById("barInner");
    const targetNameEl = document.getElementById("targetName");

    let score = 0;

    // ---------- Helpers ----------
    const raycaster = new THREE.Raycaster();
    const forward = new THREE.Vector3();
    const tmpVec = new THREE.Vector3();

    function getForwardDir() {
      // player forward in world space
      player.getWorldDirection(forward);
      forward.y = 0;
      forward.normalize();
      return forward;
    }

    function findBestTreeTarget() {
      // We pick the closest tree that is roughly in front of the player.
      const maxDist = 4.0;
      const fwd = getForwardDir();

      let best = null;
      let bestScore = -Infinity;

      for (const t of trees) {
        if (!t.userData.alive) continue;

        tmpVec.copy(t.position).sub(player.position);
        const dist = tmpVec.length();
        if (dist > maxDist) continue;

        tmpVec.normalize();
        const facing = fwd.dot(tmpVec); // 1 = perfect, -1 behind
        if (facing < 0.35) continue; // must be somewhat in front

        // score closer + more centered
        const s = (1.0 / (dist + 0.001)) + facing * 0.5;
        if (s > bestScore) {
          bestScore = s;
          best = t;
        }
      }

      return best;
    }

    function clamp01(x){ return Math.max(0, Math.min(1, x)); }

    // ---------- Game loop ----------
    const clock = new THREE.Clock();

    // Movement tuning
    const baseSpeed = 6.0;
    const sprintSpeed = 10.0;
    const turnSpeed = 10.0; // higher = snappier

    // Chop tuning
    const chopRate = 0.55; // hp per second (so ~1.8s per tree)

    function animate() {
      requestAnimationFrame(animate);
      const dt = Math.min(clock.getDelta(), 0.05);

      // --- Movement ---
      const sprint = keys.has("ShiftLeft") || keys.has("ShiftRight");
      const speed = sprint ? sprintSpeed : baseSpeed;

      // movement direction in world space (camera-relative)
      const move = new THREE.Vector3();
      const camForward = new THREE.Vector3();
      camera.getWorldDirection(camForward);
      camForward.y = 0;
      camForward.normalize();

      const camRight = new THREE.Vector3().crossVectors(camForward, new THREE.Vector3(0,1,0)).normalize().multiplyScalar(-1);

      if (keys.has("KeyW")) move.add(camForward);
      if (keys.has("KeyS")) move.sub(camForward);
      if (keys.has("KeyA")) move.sub(camRight);
      if (keys.has("KeyD")) move.add(camRight);

      if (move.lengthSq() > 0) {
        move.normalize();

        // rotate player toward movement direction
        const targetYaw = Math.atan2(move.x, move.z);
        const currentYaw = player.rotation.y;

        // shortest-angle lerp
        let deltaYaw = targetYaw - currentYaw;
        while (deltaYaw > Math.PI) deltaYaw -= Math.PI * 2;
        while (deltaYaw < -Math.PI) deltaYaw += Math.PI * 2;

        player.rotation.y += deltaYaw * Math.min(1, turnSpeed * dt);

        // translate
        player.position.addScaledVector(move, speed * dt);
      }

      // keep player on ground
      player.position.y = 0;

      // --- Camera follow ---
      // offset behind player, based on player rotation
      const behind = new THREE.Vector3(0, 0, 1).applyAxisAngle(new THREE.Vector3(0,1,0), player.rotation.y);
      const camPos = player.position.clone()
        .addScaledVector(behind, 10)
        .add(new THREE.Vector3(0, 6, 0));

      // smooth camera
      camera.position.lerp(camPos, 1 - Math.pow(0.001, dt));
      camera.lookAt(player.position.x, player.position.y + 1.2, player.position.z);

      // --- Targeting / Chopping ---
      const target = findBestTreeTarget();
      targetNameEl.textContent = target ? target.name : "None";

      if (target && isChopping) {
        target.userData.hp = clamp01(target.userData.hp - chopRate * dt);

        // crude feedback: wiggle the axe + tree
        axe.rotation.z = Math.sin(performance.now() * 0.05) * 0.6;
        target.rotation.z = Math.sin(performance.now() * 0.03) * 0.08;

        if (target.userData.hp <= 0 && target.userData.alive) {
          target.userData.alive = false;

          // remove tree (simple)
          treeGroup.remove(target);

          score += 1;
          scoreEl.textContent = String(score);
        }
      } else {
        axe.rotation.z = 0;
      }

      // Update chop bar
      if (target) {
        const pct = (1 - (target.userData.hp / target.userData.maxHp)) * 100;
        barInner.style.width = `${pct.toFixed(1)}%`;
      } else {
        barInner.style.width = `0%`;
      }

      renderer.render(scene, camera);
    }

    animate();

    // ---------- Resize ----------
    window.addEventListener("resize", () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
  </script>
</body>
</html>
